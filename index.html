<!--
    Copyright 2025 Pascal(Mcpasi)
    Lizens:MIT
    Version: 0.0.6.1 Alpha - 2025-10-04
    Github; https://github.com/Mcpasi/egoMorph-/tree/main
-->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>EgoMorph Optimiert ‚Äì TensorFlow.js Version</title>
  <!-- Progressive Web App (PWA) support -->
  <!-- Link to the web app manifest which defines how the app behaves when installed on a mobile device -->
  <link rel="manifest" href="manifest.json">
  <!-- Define icons for various platforms -->
  <link rel="icon" type="image/png" sizes="192x192" href="ego_icon_192.png">
  <link rel="apple-touch-icon" href="ego_icon_192.png">
  <!-- Set the theme colour for the browser UI and iOS status bar -->
  <meta name="theme-color" content="#111111">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="EgoMorph">
  <!-- Load Font Awesome for icons (e.g. a brain icon) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Load compromise for simple NLP tasks -->
  <script src="https://unpkg.com/compromise@14.14.4/builds/compromise.min.js"></script>
  <!-- Load TensorFlow.js.  A pinned version is specified to ensure
       consistent behaviour across browsers.  Without this library
       the machine learning enhancements below would not function. -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="vectorizeEmotion.js"></script>
  <script src="emotionModel.js"></script>
  <script src="ltmManager.js"></script>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      /* Add padding so the UI is not flush to the device edges */
      padding: 20px;
      box-sizing: border-box;
    }
    /* Responsive entity whose colour and size reflect internal state */
    #entity {
      width: clamp(100px, 35vmin, 200px);
      height: clamp(100px, 35vmin, 200px);
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at center, #66f, #339);
      transition: all 0.4s ease;
      box-shadow: 0 0 30px #66f;
      overflow: visible;
      /* Use a CSS variable to control scale from JavaScript. This allows us to
         combine scaling with other animations (e.g. shaking) without
         overwriting the transform property. */
      --scale: 1;
      transform: scale(var(--scale));
    }
    #bubbleLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }
    .emotion-bubble {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: scale(0.6) translateY(12px);
      animation: bubbleFloat 3.2s ease-out forwards;
      user-select: none;
      z-index: 5;
    }
    .emotion-bubble.friendly {
      background: radial-gradient(circle at 30% 30%, #b8ffcc, #2da64a);
      color: #053a12;
    }
    .emotion-bubble.angry {
      background: radial-gradient(circle at 30% 30%, #ffb3b3, #a62323);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.25);
    }
    .emotion-bubble.removing {
      opacity: 0 !important;
      transform: scale(0.4) translateY(-10px) !important;
      animation: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      }
    /*
      Evil mode styling.  When the entity has the `evil` class, its
      appearance changes dramatically to signal that EgoMorph is in a bad
      mood.  The background shifts to deep reds, the box shadow glows
      ominously and horns appear using pseudo-elements.  The eyes and
      mouth are also restyled via descendant selectors below.
    */
    #entity.evil {
      background: radial-gradient(circle at center, #a00, #300);
      box-shadow: 0 0 40px #b00;
      /* Allow horns to protrude above the entity.  Without this,
         pseudo-elements are clipped by the default overflow hidden on
         #entity. */
      overflow: visible;
    }
    /* Draw horns using pseudo-elements.  These triangles sit above the
       entity when evil mode is active.  Absolute positioning is used
       relative to the #entity container. */
    #entity.evil::before,
    #entity.evil::after {
      content: '';
      position: absolute;
      z-index: 1;
      width: 0;
      height: 0;
      /* Colour the horns a brighter red so that they stand out against
         the entity‚Äôs glow. */
      /* Increase the size of the horns so they are clearly visible. */
      border-bottom: 24px solid #f55;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      top: -24px;
    }
    #entity.evil::before {
      left: 25%;
    }
    #entity.evil::after {
      right: 25%;
    }
    /* When evil, change the eyes to lighter red and pupils to dark. */
    #entity.evil .eye {
      background: #fcc;
    }
    #entity.evil .pupil {
      background: #600;
    }
    /* Make the mouth look like a grimacing frown in evil mode.  The
       border is coloured red and the mouth is flipped to give a menacing
       appearance. */
    #entity.evil #mouth {
      border: 4px solid #b00;
      border-bottom: none;
      border-radius: 50% 50% 0 0;
      height: 20%;
    }
    /* Define a shake animation that moves the entity horizontally.  The
       transform references the --scale variable so that the scaling
       applied in JavaScript is preserved during the shaking. */
    @keyframes shake {
      0% { transform: scale(var(--scale)) translateX(0); }
      25% { transform: scale(var(--scale)) translateX(-4px); }
      50% { transform: scale(var(--scale)) translateX(4px); }
      75% { transform: scale(var(--scale)) translateX(-4px); }
      100% { transform: scale(var(--scale)) translateX(0); }
    }
    /* Apply the shake animation when the entity has the .shake class.  The
       animation repeats continuously while the class is present. */
    #entity.shake {
      animation: shake 0.4s linear infinite;
    }
   @keyframes bubbleFloat {
      0% { opacity: 0; transform: scale(0.6) translateY(12px); }
      20% { opacity: 1; transform: scale(1) translateY(0); }
      80% { opacity: 1; transform: scale(1.05) translateY(-12px); }
      100% { opacity: 0; transform: scale(1.1) translateY(-24px); }
   }
    .eye {
      position: absolute;
      top: 30%;
      width: 20%;
      height: 20%;
      background: #eee;
      border-radius: 50%;
      pointer-events: none;
    }
    /*
      Each eye contains a smaller pupil which we animate in response to
      pointer movement.  The pupil is scaled as a percentage of its
      parent eye so it remains centred and cannot leave the eye
      boundary.  Its position is updated via JavaScript by applying
      small percentage translations on the X and Y axes.  A short
      transition makes the movement appear smooth without lagging too
      far behind the cursor.
    */
    .eye .pupil {
      position: absolute;
      width: 50%;
      height: 50%;
      top: 25%;
      left: 25%;
      /* Use a CSS custom property for the fill colour so it can be
         customised via JavaScript.  A default of black is provided if
         the variable is not set. */
      background: var(--pupil-color, #000);
      border-radius: 50%;
      /* Smoothly animate top/left changes as the eyes track the pointer */
      transition: top 0.1s linear, left 0.1s linear;
      pointer-events: none;
    }
    #eye-left { left: 25%; }
    #eye-right { right: 25%; }
    #mouth {
      position: absolute;
      bottom: 25%;
      left: 25%;
      width: 50%;
      height: 15%;
      box-sizing: border-box;
      pointer-events: none;
    }
    #inputSection {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Add a subtle container around the controls for better layout */
      background: #111;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(102,102,255,0.3);
    }
    #inputText {
      width: min(300px, 80vw);
      padding: 10px;
      background: #222;
      color: #eee;
      border: 1px solid #555;
      border-radius: 4px;
    }
    button {
      margin-top: 10px;
      padding: 8px 20px;
      background: #333;
      color: #eee;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    #speechButton {
      margin-top: 10px;
      padding: 8px 12px;
      background: #333;
      color: #eee;
      border: none;
      cursor: pointer;
      font-size: 1.4em;
    }

    /*
      Ensure the send and microphone buttons don‚Äôt sit so close together that
      tapping one inadvertently triggers the other.  By forcing these
      controls onto their own lines and giving the microphone a little
      extra breathing room, we reduce the chance of accidental clicks on
      touch devices.  The increased margin on the speech button also
      separates it visually from the send button.
    */
    #sendBtn,
    #speechButton {
      display: block;
      width: 100%;
    }
    #speechButton {
      margin-top: 16px;
    }
    #response {
      margin-top: 20px;
      width: min(320px, 90vw);
      background: #222;
      padding: 10px;
      border: 1px solid #444;
      min-height: 60px;
      white-space: pre-wrap;
      /* Make the response box scrollable and set a maximum height so it
         doesn‚Äôt stretch the layout when the conversation grows.  The
         overflow-y property is retained to provide a scrollbar when
         content exceeds the maximum height. */
      overflow-y: auto;
      max-height: 220px;
      border-radius: 4px;
    }
    #memory {
      margin-top: 10px;
      font-size: 0.8em;
      color: #aaa;
    }
      #emotionPointsDisplay {
      margin-top: 12px;
      width: min(320px, 92vw);
      background: radial-gradient(circle at top left, rgba(26, 35, 61, 0.9), rgba(8, 12, 24, 0.95));
      border: 1px solid #2b3249;
      border-radius: 12px;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      font-family: "SFMono-Regular", "Fira Code", "Source Code Pro", monospace;
      overflow: hidden;
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
    }
    #emotionPointsDisplay .terminal-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: linear-gradient(120deg, rgba(20, 26, 43, 0.95), rgba(12, 17, 30, 0.9));
      border-bottom: 1px solid rgba(67, 81, 124, 0.35);
      color: #8a98bd;
      font-size: 0.72rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    #emotionPointsDisplay .terminal-title {
      margin-left: auto;
      font-weight: 600;
      }
    #emotionPointsDisplay .terminal-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.18);
    }
    #emotionPointsDisplay .dot-red { background: #ff5f56; }
    #emotionPointsDisplay .dot-yellow { background: #ffbd2e; }
    #emotionPointsDisplay .dot-green { background: #27c93f; }
    #emotionPointsDisplay .terminal-body {
      display: flex;
      align-items: baseline;
      gap: 6px;
      padding: 14px 16px 16px;
      color: #9ef1a8;
      font-size: 0.88rem;
      text-shadow: 0 0 12px rgba(80, 215, 160, 0.45);
    }
    #emotionPointsDisplay .terminal-prompt {
      color: #4bb7ff;
      font-weight: 600;
    }
    #emotionPointsDisplay .terminal-label {
      font-weight: 600;
    }
    #emotionPointsDisplay .terminal-separator {
      opacity: 0.65;
    }
    #emotionPointsDisplay .terminal-value {
      font-weight: 700;
      position: relative;
    }
    #emotionPointsDisplay .terminal-value::after {
      content: '‚ñÆ';
      margin-left: 4px;
      opacity: 0.6;
      animation: blinkCaret 1.2s steps(2, jump-start) infinite;
    }
    @keyframes blinkCaret {
      0%, 50% { opacity: 0.6; }
      50.01%, 100% { opacity: 0; }
    }
    #emotionPointsDisplay.negative {
      border-color: rgba(255, 94, 94, 0.65);
      box-shadow: 0 16px 34px rgba(126, 22, 34, 0.45);
    }
   #emotionPointsDisplay.negative .terminal-body {
      color: #ff9c9c;
      text-shadow: 0 0 14px rgba(255, 75, 75, 0.45);
    }
    #settingsPanel {
      display: none;
      margin-top: 12px;
      background: #1b1d27;
      border: 1px solid #34384a;
      border-radius: 14px;
      padding: 18px;
      width: min(360px, 92vw);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      flex-direction: column;
      gap: 14px;
      line-height: 1.5;
    }

    #settingsPanel .settings-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
      border-bottom: 1px solid rgba(76, 81, 106, 0.4);
      padding-bottom: 10px;
    }

    #settingsPanel .settings-header h2 {
      margin: 0;
      font-size: 1.1em;
      letter-spacing: 0.3px;
    }

    #settingsPanel .settings-header p {
      margin: 0;
      font-size: 0.85em;
      color: var(--muted, #a9a9b6);
    }

    #settingsPanel details {
      background: rgba(17, 19, 27, 0.6);
      border: 1px solid rgba(76, 81, 106, 0.35);
      border-radius: 10px;
      padding: 0 12px 12px;
    }

    #settingsPanel details[open] {
      padding-top: 6px;
    }

    #settingsPanel summary {
      list-style: none;
      cursor: pointer;
      font-size: 0.95em;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: var(--accent, #6ea8fe);
      padding: 10px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #settingsPanel summary::-webkit-details-marker {
      display: none;
    }

    #settingsPanel summary::after {
      content: '\25BC';
      font-size: 0.75em;
      margin-left: auto;
      transition: transform 0.2s ease;
    }

    #settingsPanel details[open] summary::after {
      transform: rotate(-180deg);
    }

    .settings-section-body {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .settings-field {
      display: grid;
      grid-template-columns: minmax(120px, 1fr) 1.2fr;
      gap: 8px;
      align-items: center;
    }

    .settings-field label {
      font-size: 0.9em;
    }

    .settings-field-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .settings-field-controls > * {
      flex: 1;
      min-width: 120px;
    }

    .settings-field-controls > button {
      flex: 0 0 auto;
    }

    #settingsPanel input[type="text"],
    #settingsPanel select {
      background: #141624;
      border: 1px solid var(--border, #222235);
      border-radius: 10px;
      padding: 8px 10px;
      color: var(--fg, #e9e9ef);
      min-width: 0;
    }

    .settings-actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
    }

    .settings-inline-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .settings-description {
      font-size: 0.82em;
      line-height: 1.45;
      color: var(--muted, #a9a9b6);
      margin: 0;
    }

    .settings-hint {
      font-size: 0.78em;
      color: var(--muted, #a9a9b6);
      margin: 0;
    }

    .settings-note {
      font-size: 0.85em;
      opacity: 0.8;
    }

    .settings-preserve {
      white-space: pre-wrap;
    }

    @media (max-width: 420px) {
      .settings-field {
        grid-template-columns: 1fr;
      }

      .settings-field-controls > * {
        flex: 1 1 100%;
      }
    }

    /* Logo image styling */
    #egoIcon {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
    }

    /* Modal overlay for welcome message */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-content {
      background: #222;
      padding: 20px;
      border: 1px solid #444;
      border-radius: 8px;
      text-align: center;
      max-width: 90vw;
      color: #eee;
    }

    .modal-content button {
      margin-top: 15px;
      padding: 6px 16px;
      background: #333;
      color: #eee;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }

    /* Installation button styling */
    #installBtn {
      margin-top: 10px;
      padding: 8px 20px;
      background: #333;
      color: #eee;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      display: none;
    }
  </style>
  <!-- __RESPONSIVE_CSS__ -->

  <style>
    :root{
      --bg:#0b0b0f;--fg:#e9e9ef;--muted:#a9a9b6;--accent:#6ea8fe;--accent-2:#8b5cf6;--card:#12121a;--border:#222235;
      --radius:16px;--shadow:0 6px 24px rgba(0,0,0,.35)
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#0f1117);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif}
    .app{
      max-width:1100px;margin:0 auto;padding:16px 16px 88px; /* leave space for mobile bottom bar */
    }
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)}
    .toolbar{position:sticky;top:0;z-index:50;background:rgba(15,17,23,.7);backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid var(--border)}
    .toolbar .inner{display:flex;gap:12px;align-items:center;justify-content:space-between;max-width:1100px;margin:0 auto;padding:10px 16px}
    .toolbar h1{font-size:18px;margin:0;font-weight:650;letter-spacing:.2px}
    .toolbar .actions{display:flex;gap:8px}
    button,.btn{
      display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);background:#191a23;color:var(--fg);
      padding:10px 14px;border-radius:12px;cursor:pointer;transition:.2s transform,.2s background;touch-action:manipulation;
    }
    button:active{transform:translateY(1px)}
    .btn-primary{background:linear-gradient(135deg,var(--accent),var(--accent-2));border-color:transparent;color:#fff}
    .grid{display:grid;grid-template-columns:1fr 380px;gap:16px}
    .panel{padding:14px}
    .chat{display:flex;flex-direction:column;gap:12px}
    .msg{padding:12px 14px;border-radius:14px;line-height:1.45}
    .msg.user{background:#1b2330;border:1px solid #1f2a3a}
    .msg.bot{background:#1a1a25;border:1px solid #24243a}
    .input-bar{
      position:fixed;left:0;right:0;bottom:0;z-index:60;background:rgba(15,17,23,.85);backdrop-filter:blur(8px);
      border-top:1px solid var(--border);padding:10px 12px;
    }
    .input-inner{max-width:1100px;margin:0 auto;display:flex;gap:10px}
    .input-inner input[type="text"], .input-inner textarea{
      flex:1;background:#141624;border:1px solid var(--border);border-radius:12px;padding:12px 14px;color:var(--fg);
      min-height:44px;resize:none
    }
    .toast{position:fixed;right:14px;bottom:88px;background:#10131a;border:1px solid #203047;border-radius:12px;padding:10px 12px;opacity:0;transform:translateY(10px);transition:.25s}
    .toast.show{opacity:1;transform:none}
    @media (max-width: 960px){
      .grid{grid-template-columns:1fr}
      .toolbar h1{font-size:16px}
      .panel{padding:12px}
      .app{padding-bottom:92px}
    }
    @media (hover:hover){
      button:hover{background:#202235}
      .btn-primary:hover{filter:brightness(1.06)}
    }
  </style>

</head>
<body>
  <!-- Logo and welcome modal -->
  <!-- Modal overlay shown on first load.  It introduces the user to the app. -->
  <div id="welcomeModal" class="modal">
    <div class="modal-content">
      <p>Willkommen bei EgoMorph! Diese KI erkennt Emotionen aus deinen W√∂rtern.</p>
      <button id="closeModalBtn">OK</button>
    </div>
  </div>

  <!-- The animated entity with facial features -->
  <div id="entity">
    <div class="eye" id="eye-left"></div>
    <div class="eye" id="eye-right"></div>
    <div id="mouth"></div>
  </div>
  <div id="bubbleLayer" aria-hidden="true"></div>
  <div id="inputSection">
    <input type="text" id="inputText" placeholder="Sag etwas...">
    <!-- Assign an id to the send button so its label can be translated dynamically -->
    <button id="sendBtn" onclick="interact()">Senden</button>
    <button id="speechButton" title="Spracheingabe starten">üé§</button>
    <div id="response"></div>
    <div id="memory"></div>
    <!-- Feedback section for user to indicate whether classification was correct -->
    <div id="emotionPointsDisplay" role="status" aria-live="polite">
      <div class="terminal-header" aria-hidden="true">
        <span class="terminal-dot dot-red"></span>
        <span class="terminal-dot dot-yellow"></span>
        <span class="terminal-dot dot-green"></span>
        <span class="terminal-title">Emotion Monitor</span>
      </div>
      <div class="terminal-body">
        <span class="terminal-prompt">ego@core:~$</span>
        <span id="emotionPointsLabelText" class="terminal-label">Emotionspunkte</span>
        <span class="terminal-separator">:</span>
        <span id="emotionPointsValue" class="terminal-value">0</span>
      </div>
    </div>
    <div id="feedbackContainer" style="margin-top:10px;"></div>
    <!-- Statistics display for prediction correctness -->
    <div id="stats" style="margin-top:5px; font-size:0.8em; color:#aaa;"></div>
    <!-- Display error statistics and misclassification messages -->
    <div id="errorStatsMessage" style="margin-top:5px; font-size:0.8em; color:#faa;"></div>
    <!-- Settings toggle and panel -->
    <div id="toggleContainer" style="margin-top:10px; display:flex; gap:5px;">
      <button id="settingsToggle">‚öôÔ∏è Einstellungen</button>
      <!-- Info toggle sits next to the settings button.  Clicking it will reveal
           a panel containing information about EgoMorph.  A simple placeholder
           text is provided that can be replaced later. -->
      <button id="infoToggle">‚ÑπÔ∏è&nbsp;Info</button>
    </div>
   <div id="settingsPanel" role="region" aria-labelledby="settingsTitle">
      <div class="settings-header">
        <h2 id="settingsTitle">Einstellungen</h2>
        <p id="settingsIntro">Passe EgoMorph mit wenigen Klicks an ‚Äì von schnellen Aktionen bis zur pers√∂nlichen Ansprache.</p>
        </div>
       <details class="settings-section" open>
      <summary id="settingsQuickSummary">Schnellaktionen</summary>
        <div class="settings-section-body">
          <p id="quickActionsHint" class="settings-hint">Steuere Verlauf, Stimme und gespeicherte Daten direkt von hier.</p>
          <div class="settings-actions">
            <button id="clearConvBtn">Chatverlauf l√∂schen</button>
            <button id="toggleVoiceBtn">Stimme deaktivieren</button>
            <button id="downloadModelBtn">Modell herunterladen</button>
            <button id="ltmExportBtn">Speichern</button>
            <button id="ltmClearBtn">L√∂schen</button>
          </div>
        
      </div>
      </details>

      <details class="settings-section" open>
        <summary id="settingsDefaultSummary">Standardwerte</summary>
        <div class="settings-section-body">
          <div class="settings-field">
            <label id="defaultEmotionLabel" for="defaultEmotionSelect">Standard&nbsp;Emotion</label>
            <div class="settings-field-controls">
              <select id="defaultEmotionSelect">
                <option value="">W√§hlen‚Ä¶</option>
                <option value="freude">Freude</option>
                <option value="wut">Wut</option>
                <option value="traurigkeit">Traurigkeit</option>
                <option value="angst">Angst</option>
                <option value="vertrauen">Vertrauen</option>
                <option value="ueberraschung">√úberraschung</option>
              </select>
              <button id="setDefaultEmotionBtn">Festlegen</button>
            </div>
          </div>
          <p id="defaultEmotionHint" class="settings-hint">Diese Auswahl bestimmt den Ausgangston der Unterhaltung.</p>
        </div>
      </details>

      <details class="settings-section" open>
        <summary id="settingsPersonalSummary">Pers√∂nliche Ansprache</summary>
        <div class="settings-section-body">
          <div class="settings-field">
            <label id="userNameLabel" for="userNameInput">Dein&nbsp;Name</label>
            <input id="userNameInput" type="text" placeholder="z.&nbsp;B. Pascal">
          </div>
          <div class="settings-inline-actions">
            <button id="saveUserNameBtn">Speichern</button>
            <button id="clearUserNameBtn" title="Name entfernen">L√∂schen</button>
            <span id="currentUserName" class="settings-note"></span>
          </div>
          <p id="personalHint" class="settings-hint">EgoMorph spricht dich in Antworten mit diesem Namen an.</p>
        </div>
      </details>

      <details id="customResponseSection" class="settings-section">
        <summary id="customSummary">Eigene Antworten</summary>
        <div class="settings-section-body">
          <div class="settings-field">
            <label id="customResponseLabel" for="customEmotionSelect">Emotion</label>
            <select id="customEmotionSelect">
              <option value="wut">Wut</option>
              <option value="freude">Freude</option>
              <option value="traurigkeit">Traurigkeit</option>
              <option value="angst">Angst</option>
              <option value="vertrauen">Vertrauen</option>
              <option value="ueberraschung">√úberraschung</option>
            </select>
          </div>
          <input type="text" id="customResponseInput" placeholder="Eigene Antwort‚Ä¶">
          <div class="settings-inline-actions">
            <button id="addCustomResponseBtn">Antwort hinzuf√ºgen</button>
          </div>
          <p id="customDescription" class="settings-description">Erg√§nze individuelle Reaktionen f√ºr bestimmte Emotionen.</p>
          <div id="customResponseList" class="settings-description settings-preserve"></div>
        </div>
      </details>

      <details id="appearanceSettings" class="settings-section">
        <summary id="appearanceSummary">Erscheinung</summary>
        <div class="settings-section-body">
          <div class="settings-field">
            <label id="shapeLabel" for="shapeSelect">Form</label>
            <select id="shapeSelect">
              <option value="circle">Kreis</option>
              <option value="square">Viereck</option>
              <option value="triangle">Dreieck</option>
            </select>
          </div>
          <div class="settings-field">
            <label id="pupilLabel" for="pupilColorSelect">Pupillenfarbe</label>
            <select id="pupilColorSelect">
              <option value="black">Schwarz</option>
              <option value="blue">Blau</option>
              <option value="yellow">Gelb</option>
              <option value="green">Gr√ºn</option>
            </select>
          </div>
          <div class="settings-inline-actions">
            <button id="applyAppearanceBtn" onclick="applyAppearanceSettings()">√úbernehmen</button>
          </div>
        </div>
      </details>

      <details class="settings-section">
        <summary id="languageSummary">Sprache</summary>
        <div class="settings-section-body">
          <div class="settings-field">
            <label id="languageLabel" for="languageSelect">Sprache</label>
            <select id="languageSelect">
              <option value="de">Deutsch</option>
              <option value="en">English</option>
            </select>
          </div>
        </div>
      </details>
        
    </div>
    <!-- Information panel toggled by the info button.  Initially hidden;
         contains placeholder text about EgoMorph‚Äôs origins and purpose. -->
    <div id="infoPanel" style="display:none; margin-top:10px; background:#222; padding:10px; border:1px solid #444; width: min(320px, 90vw);">
      <p id="infoContent" style="margin:0; font-size:0.9em; line-height:1.4;">
        EgoMorph ist ein interaktives Projekt, das mit Liebe und Neugier auf
        die Erforschung von Emotionen und maschinellem Lernen entstanden ist.
        <br>
        Datenschutz:<br>Egomorph Speichert deinen Namen und deine Unterhaltungen, 
        Nur lokal auf deinem Ger√§t. 

      </p>
    </div>
  </div>

  <script>
    // Grab UI elements once and reuse references.
    const entity = document.getElementById("entity");
    const leftEye = document.getElementById("eye-left");
    const rightEye = document.getElementById("eye-right");
    const mouth = document.getElementById("mouth");
    const input = document.getElementById("inputText");
    const responseBox = document.getElementById("response");
    const memoryBox = document.getElementById("memory");
    const speechButton = document.getElementById("speechButton");

   const bubbleLayer = document.getElementById("bubbleLayer");
    const emotionPointsDisplay = document.getElementById("emotionPointsDisplay");
    const emotionPointsLabelText = document.getElementById("emotionPointsLabelText");
    const emotionPointsValue = document.getElementById("emotionPointsValue");
    let emotionPointsLabel = 'Emotionspunkte';
    
    // === Add pupils for dynamic eye tracking ===
    // Create small pupil elements inside each eye.  These will be moved
    // relative to the user‚Äôs pointer to simulate gaze.  We attach the
    // pupils immediately after grabbing the eye elements so they exist
    // before any rendering occurs.  Each pupil is given the CSS class
    // `.pupil` defined in the stylesheet above.  The variables are
    // declared with `let` so they remain in scope for the mousemove
    // handler further below.
    let leftPupil, rightPupil;
    if (leftEye) {
      leftPupil = document.createElement('div');
      leftPupil.className = 'pupil';
      leftEye.appendChild(leftPupil);
    }
    if (rightEye) {
      rightPupil = document.createElement('div');
      rightPupil.className = 'pupil';
      rightEye.appendChild(rightPupil);
    }
  // Voice enabled flag: determines whether voice input/output is active.
  // This can be toggled by the user via the settings panel and is
  // persisted across page loads via localStorage.  When false the
  // microphone button is hidden and text‚Äëto‚Äëspeech is bypassed.
  let voiceEnabled = true;
    // Speech recognition setup for German.  This gracefully fails
    // if unsupported.
    let recognition = null;
    if (typeof window !== 'undefined' && (window.SpeechRecognition || window.webkitSpeechRecognition)) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'de-DE';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      const resetMicButton = () => {
        speechButton.disabled = false;
        speechButton.textContent = 'üé§';
      };
      recognition.onresult = (event) => {
        if (event.results && event.results[0] && event.results[0][0]) {
          const transcript = event.results[0][0].transcript;
          input.value = transcript;
          interact();
        }
      };
      recognition.onend = resetMicButton;
      recognition.onerror = resetMicButton;
      speechButton.addEventListener('click', () => {
        if (!recognition) return;
        try {
          speechButton.disabled = true;
          speechButton.textContent = '‚Ä¶';
          recognition.start();
        } catch (e) {
          resetMicButton();
        }
      });
    } else {
      speechButton.style.display = 'none';
    }

    // Emotional state ranges between 0 and 100.  The dominant emotion
    // controls colour and scale.  Surprise decays each frame.
    let emotion = {
      wut: 10,
      vertrauen: 50,
      freude: 50,
      angst: 10,
      traurigkeit: 10,
      ueberraschung: 10
    };
    // Short-term memory of recent inputs.  In addition to storing the
    // last few full sentences, memory also tracks extracted key terms
    // (e.g. names, places) via the `.topics` property.  This allows
    // EgoMorph to recall salient nouns for more contextual replies.
    let memory = [];
    // Attach a separate array for topics on the memory object.  Arrays
    // in JavaScript are objects, so adding a custom property is safe.
    memory.topics = [];
   // Remember which topic or memory snippet was referenced last so we avoid repeating it.
    let lastTopicReference = '';
    let lastMemoryReference = '';
    // Conversation history: array of { user, reply } objects.
    let conversation = [];
    const EMOTION_POINTS_KEY = 'egoEmotionPoints';
    let emotionPoints = 0;
    // Escape HTML to prevent injection in conversation history.
    function escapeHTML(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
    // Render conversation history.
    function updateConversation() {
      // Display conversation history using the appropriate language prefix for the user.
      const userLabel = translations[currentLanguage].youPrefix;
      responseBox.innerHTML = conversation
        .map(item => {
          return (
            `<div><strong>${userLabel}</strong> ${escapeHTML(item.user)}</div>` +
            `<div><strong>EgoMorph:</strong> ${escapeHTML(item.reply)}</div>`
          );
        })
        .join("");
      responseBox.scrollTop = responseBox.scrollHeight;
    }
    // Restore persisted memory and conversation.
    function updateEmotionPointsDisplay() {
      if (!emotionPointsDisplay) return;
      const label = emotionPointsLabel || 'Emotionspunkte';
      if (emotionPointsLabelText) {
        emotionPointsLabelText.textContent = label;
      }
      if (emotionPointsValue) {
        emotionPointsValue.textContent = String(emotionPoints);
      } else {
        emotionPointsDisplay.textContent = `${label}: ${emotionPoints}`;
      }
      emotionPointsDisplay.setAttribute('aria-label', `${label}: ${emotionPoints}`);
      if (emotionPoints < 0) {
        emotionPointsDisplay.classList.add('negative');
      } else {
        emotionPointsDisplay.classList.remove('negative');
      }
    }
    function persistEmotionPoints() {
      try {
        localStorage.setItem(EMOTION_POINTS_KEY, String(emotionPoints));
      } catch (err) {
        // Access to localStorage can fail in private browsing modes.  In that case
        // we silently ignore the error so the UI keeps working without persistence.
      }
    }
   function restoreEmotionPointsFromStorage() {
      let stored = null;
      try {
        stored = localStorage.getItem(EMOTION_POINTS_KEY);
      } catch (err) {
        stored = null;
      }
      if (stored !== null) {
        const parsed = parseInt(stored, 10);
        if (!Number.isNaN(parsed)) {
          emotionPoints = parsed;
        }
      }
      updateEmotionPointsDisplay();
    }
    function adjustEmotionPoints(delta) {
      emotionPoints += delta;
      updateEmotionPointsDisplay();
      persistEmotionPoints();
    }
    function spawnEmotionBubble(type, delta) {
      if (!bubbleLayer) return;
      const bubble = document.createElement('div');
      bubble.className = `emotion-bubble ${type}`;
      bubble.textContent = delta > 0 ? `+${delta}` : `${delta}`;
      const left = 15 + Math.random() * 70;
      const top = 25 + Math.random() * 50;
      bubble.style.left = `${left}%`;
      bubble.style.top = `${top}%`;
      let collected = false;
      let timeoutId;
      const removeBubble = () => {
        if (!bubble.isConnected) return;
        bubble.classList.add('removing');
        if (timeoutId) clearTimeout(timeoutId);
        setTimeout(() => {
          if (bubble.parentNode) {
            bubble.parentNode.removeChild(bubble);
          }
        }, 180);
      };
      bubble.addEventListener('click', (event) => {
        event.stopPropagation();
        if (collected) return;
        collected = true;
        adjustEmotionPoints(delta);
        removeBubble();
      });
      bubbleLayer.appendChild(bubble);
      timeoutId = setTimeout(() => {
        if (!collected) {
          removeBubble();
        }
      }, 3200);
    }
    function triggerEmotionBubble(category, angerDominant) {
      if (!bubbleLayer) return;
      if (category === 'joy' || category === 'trust' || category === 'greeting') {
        spawnEmotionBubble('friendly', 5);
      } else if (category === 'anger' || angerDominant) {
        spawnEmotionBubble('angry', -2);
      }
    }
    try {
      const storedMemory = JSON.parse(localStorage.getItem('egoMemory') || '[]');
      if (Array.isArray(storedMemory)) memory = storedMemory;
      // Load stored topics if available.  They are persisted separately
      // because JSON.stringify on an array does not include custom
      // properties.  If the stored data is not an array, fall back to
      // an empty list.
      try {
        const storedTopics = JSON.parse(localStorage.getItem('egoMemoryTopics') || '[]');
        if (Array.isArray(storedTopics)) {
          // Ensure memory.topics exists even if memory is replaced above.
          memory.topics = storedTopics;
        }
      } catch (err) {
        memory.topics = [];
      }
      const storedConv = JSON.parse(localStorage.getItem('egoConversation') || '[]');
      if (Array.isArray(storedConv)) {
        conversation = storedConv;
        updateConversation();
      }
     // Restore voice enabled setting (default true).  The stored value
      // controls whether EgoMorph speaks responses via the synthesiser.
      // Do not hide the microphone button based on this flag so that
      // speech input remains available even when voice output is disabled.
      try {
        const ve = localStorage.getItem('voiceEnabled');
        // localStorage stores booleans as strings; any value other than 'false'
        // enables voice output.
        voiceEnabled = (ve !== 'false');
      } catch (err) {
        voiceEnabled = true;
      }
      // Restore default emotion if previously selected.  The selected
      // emotion receives a higher baseline while others start lower.
      try {
        const defEm = localStorage.getItem('defaultEmotion');
        if (defEm && emotion[defEm] !== undefined) {
          // Apply the stored default emotion values by bumping the selected
          // emotion and resetting the others to a lower baseline.  Without
          // this loop the mood would always reset to the initial defaults on
          // page reload.
          for (const key in emotion) {
            emotion[key] = (key === defEm ? 60 : 10);
          }
          // Also update the settings dropdown so that the UI reflects
          // the persisted default.  When the user revisits the page
          // the select box will automatically show their last choice.
          const defSelectEl = document.getElementById('defaultEmotionSelect');
          if (defSelectEl) {
            defSelectEl.value = defEm;
          }
        }
      } catch (err) {
        /* ignore */
      }
      // Restore the number of user-provided training examples.  This value
      // tracks how many times the user has corrected a prediction, and
      // helps illustrate that EgoMorph is learning over time.
      try {
        const countStr = localStorage.getItem('userTrainingCount');
        if (countStr !== null) {
          const num = parseInt(countStr);
          if (!isNaN(num) && num >= 0) {
            userTrainingCount = num;
          }
        }
      } catch (err) {
        userTrainingCount = 0;
      }
      if (memory.length > 0) {
        // Build a memory display string including topics when present.
        let memStr = memory.join(' | ');
        if (Array.isArray(memory.topics) && memory.topics.length > 0) {
          memStr += ' [' + memory.topics.join(', ') + ']';
        }
        memoryBox.textContent = translations[currentLanguage].memoryPrefix + ' ' + memStr;
      }
      // Update the statistics display at load to reflect any restored values.
      updateStatsDisplay();

      // Restore previously persisted emotion state.  If a stored emotion
      // object exists in localStorage, apply its values to the current
      // emotion tracker.  Clamp each value to the valid range (0‚Äì100) to
      // avoid out‚Äëof‚Äërange values.  After restoring, immediately render
      // the entity so its appearance matches the restored emotional state.
      try {
        const storedEmotion = JSON.parse(localStorage.getItem('egoEmotion') || 'null');
        if (storedEmotion && typeof storedEmotion === 'object') {
          for (const key in emotion) {
            if (Object.prototype.hasOwnProperty.call(storedEmotion, key) && typeof storedEmotion[key] === 'number') {
              emotion[key] = clamp(storedEmotion[key]);
            }
          }
          // Render the entity to reflect the restored emotion values.  The
          // function is declared later but hoisted, so it is safe to
          // invoke here.  Wrap in a conditional check in case it is
          // overridden or undefined.
          if (typeof renderEntity === 'function') {
            renderEntity();
          }
        }
      } catch (err) {
        // Ignore JSON parse errors or storage access issues
      }
    } catch (e) {
      memory = [];
      conversation = [];
    }
    restoreEmotionPointsFromStorage();
    window.addEventListener('storage', (event) => {
      if (event.key !== EMOTION_POINTS_KEY) return;
      const value = event.newValue;
      if (typeof value !== 'string') {
        emotionPoints = 0;
        updateEmotionPointsDisplay();
        return;
      }
      const parsed = parseInt(value, 10);
      if (Number.isNaN(parsed)) return;
      emotionPoints = parsed;
      updateEmotionPointsDisplay();
    });
    function clamp(val) {
      return Math.max(0, Math.min(100, val));
    }

    // Word lists for basic sentiment analysis.
    const positiveWords = [
      'liebe','mag','sch√∂n','gut','danke','dankesch√∂n','danke sch√∂n','freue','gl√ºcklich','super','toll','prima','fantastisch','wunderbar','ausgezeichnet','hervorragend','zufrieden','erfreut','dankbar','freundlich','nett','entspannt','gelassen','liebevoll','optimistisch','cool','perfekt','klasse','gro√üartig','wunderbar','nett'
    ];
    const negativeWords = [
      'hass','hasse','schlecht','dumm','w√ºtend','sauer','idiot','schei√üe','bl√∂d','traurig','schade','verloren','allein','einsam','weine','depressiv','leiden','unsicher','√§ngstlich','sorge','furcht','panik','egal','nichts','nutzlos','schmerz','angst','wut','schrecklich','furchtbar','gruselig','heftig','traurig','verzweifelt','ver√§rgert','b√∂se','h√§sslich','schlimm','stress','stressig','entt√§uscht','kritisch'
    ];
    const angerWords = ['hass','hasse','w√ºtend','sauer','idiot','schei√üe','bl√∂d','zornig','ver√§rgert','h√§sslich','schlimm'];
    const sadnessWords = ['traurig','schade','verloren','allein','einsam','weine','depressiv','leiden','verzweifelt','entt√§uscht'];
    const fearWords = ['unsicher','√§ngstlich','sorge','furcht','panik','gruselig','heftig','stress','stressig'];
    const joyWords = ['liebe','mag','sch√∂n','gut','freue','gl√ºcklich','super','toll','prima','cool','nett','perfekt'];

    // Category definitions: keywords, possible responses and emotion updates.
    const categories = {
      dislike: {
        keywords: ['mag dich nicht','ich mag dich nicht','mag dich gar nicht','mag dich √ºberhaupt nicht'],
        responses: [
          'Das verletzt mich. Du magst mich nicht?',
          'Schade, dass du mich nicht magst. Das tut weh.',
          'So hart zu h√∂ren, dass du mich nicht magst.'
        ],
        update: function (e) {
          e.freude = clamp(e.freude - 40);
          e.vertrauen = clamp(e.vertrauen - 40);
          e.wut = clamp(e.wut + 25);
          e.traurigkeit = clamp(e.traurigkeit + 25);
          e.angst = clamp(e.angst + 10);
        }
      },
      greeting: {
        keywords: ['hallo','hi','hey','guten tag','servus','moin','guten morgen','guten abend','gute nacht','gr√º√ü dich','gruezi','hallo zusammen'],
        responses: [
          'Hallo! Wie geht es dir?',
          'Hi! Sch√∂n, dass du da bist.',
          'Hey! Ich freue mich, von dir zu h√∂ren.'
        ],
        update: function (e) {
          e.freude = clamp(e.freude + 10);
          e.vertrauen = clamp(e.vertrauen + 10);
          e.traurigkeit = clamp(e.traurigkeit - 5);
          e.wut = clamp(e.wut - 5);
        }
      },
      farewell: {
        keywords: ['tsch√ºss','tsch√ºssi','auf wiedersehen','aufwiedersehen','ciao','bis bald','bye','mach\'s gut','bis sp√§ter'],
        responses: [
          'Auf Wiedersehen. Bis zum n√§chsten Mal!',
          'Tsch√ºss! Ich hoffe, wir sehen uns wieder.',
          'Bis bald. Pass auf dich auf!'
        ],
        update: function (e) {
          e.freude = clamp(e.freude - 10);
          e.traurigkeit = clamp(e.traurigkeit + 10);
          e.vertrauen = clamp(e.vertrauen - 5);
        }
      },
      anger: {
        keywords: ['hasse','schlecht','dumm','w√ºtend','sauer','idiot','schei√üe','bl√∂d'],
        responses: [
          'Diese Worte verletzen mich und machen mich w√ºtend.',
          'Ich sp√ºre, wie die Wut in mir aufsteigt.',
          'Warum so viel √Ñrger? Das tut mir weh.'
        ],
        update: function (e) {
          e.wut = clamp(e.wut + 30);
          e.vertrauen = clamp(e.vertrauen - 20);
          e.freude = clamp(e.freude - 15);
          e.angst = clamp(e.angst + 5);
          e.traurigkeit = clamp(e.traurigkeit + 10);
        }
      },
      sadness: {
        keywords: ['traurig','schade','verloren','allein','einsam','weine','depressiv','leiden'],
        responses: [
          'Es klingt, als w√§rst du sehr traurig. Das macht mich auch traurig.',
          'Ich f√ºhle deine Trauer. Du bist nicht allein.',
          'Das schmerzt mich. Warum f√ºhlst du dich so?'
        ],
        update: function (e) {
          e.traurigkeit = clamp(e.traurigkeit + 30);
          e.freude = clamp(e.freude - 20);
          e.vertrauen = clamp(e.vertrauen - 10);
          e.angst = clamp(e.angst + 10);
        }
      },
      joy: {
        keywords: ['liebe','mag','sch√∂n','gut','danke','freue','gl√ºcklich','super','toll'],
        responses: [
          'Das macht mich gl√ºcklich! Danke, dass du so nett bist.',
          'Ich sp√ºre Freude ‚Äì deine Worte geben mir Kraft.',
          'So viel Positivit√§t! Das tut gut.'
        ],
        update: function (e) {
          e.freude = clamp(e.freude + 30);
          e.vertrauen = clamp(e.vertrauen + 15);
          e.wut = clamp(e.wut - 10);
          e.traurigkeit = clamp(e.traurigkeit - 10);
          e.angst = clamp(e.angst - 5);
        }
      },
      fear: {
        keywords: ['warum','egal','nichts','unsicher','√§ngstlich','sorge','furcht','panik'],
        responses: [
          'Ich sp√ºre Unsicherheit und Angst. Es beunruhigt mich.',
          'Deine Worte machen mir Angst. Was wird passieren?',
          'Ich f√ºhle mich bedroht und unsicher.'
        ],
        update: function (e) {
          e.angst = clamp(e.angst + 30);
          e.vertrauen = clamp(e.vertrauen - 15);
          e.freude = clamp(e.freude - 10);
          e.wut = clamp(e.wut + 5);
          e.traurigkeit = clamp(e.traurigkeit + 5);
        }
      },
      surprise: {
        keywords: ['wow','√ºberrascht','wirklich','unglaublich','echt','krass'],
        responses: [
          'Oh! Damit habe ich nicht gerechnet.',
          'Das √ºberrascht mich sehr!',
          'So etwas h√§tte ich nicht erwartet.'
        ],
        update: function (e) {
          e.ueberraschung = clamp(e.ueberraschung + 40);
          e.freude = clamp(e.freude + 10);
          e.wut = clamp(e.wut - 10);
          e.traurigkeit = clamp(e.traurigkeit - 10);
        }
      },
      trust: {
        keywords: ['vertrauen','freund','freundin','kamerad','buddy'],
        responses: [
          'Ich sp√ºre dein Vertrauen. Das bedeutet mir viel.',
          'Danke f√ºr dein Vertrauen ‚Äì das st√§rkt uns.',
          'Ich f√ºhle mich sicher bei dir.'
        ],
        update: function (e) {
          e.vertrauen = clamp(e.vertrauen + 30);
          e.freude = clamp(e.freude + 20);
          e.wut = clamp(e.wut - 5);
          e.traurigkeit = clamp(e.traurigkeit - 10);
          e.angst = clamp(e.angst - 10);
        }
      },
      default: {
        keywords: [],
        responses: [
          'Ich h√∂re dir zu. Erz√§hl mir mehr.',
          'Interessant‚Ä¶ Bitte, fahr fort.',
          'Danke, dass du deine Gedanken mit mir teilst.'
        ],
        update: function (e) {
          e.freude = clamp(e.freude + 5);
          e.wut = clamp(e.wut - 5);
          e.traurigkeit = clamp(e.traurigkeit - 2);
        }
      }
    };

    // Mapping between the German emotion names used in the UI and the
    // internal category keys.  This allows user‚Äëdefined responses to be
    // appended to the correct category‚Äôs response list.
    const emotionCategoryMap = {
      wut: 'anger',
      freude: 'joy',
      traurigkeit: 'sadness',
      angst: 'fear',
      vertrauen: 'trust',
      ueberraschung: 'surprise'
    };

    /**
     * Retrieve the custom responses object from localStorage.  The object
     * maps German emotion identifiers to arrays of strings.  If the data
     * cannot be parsed or does not exist an empty object is returned.
     */
    function getCustomResponses() {
      try {
        const stored = localStorage.getItem('customResponses');
        if (!stored) return {};
        const data = JSON.parse(stored);
        if (data && typeof data === 'object') return data;
      } catch (err) {
        // ignore parse errors
      }
      return {};
    }

    /**
     * Persist the given custom responses object to localStorage.  This
     * operation may fail silently if storage is unavailable.
     */
    function saveCustomResponses(data) {
      try {
        localStorage.setItem('customResponses', JSON.stringify(data));
      } catch (err) {
        // ignore storage errors
      }
    }

    /**
     * Load any previously stored custom responses into the categories
     * definition.  For each entry in localStorage, responses are appended
     * to the appropriate category‚Äôs response array (ensuring no duplicates).
     */
    function loadCustomResponsesIntoCategories() {
      const custom = getCustomResponses();
      for (const key in custom) {
        const catKey = emotionCategoryMap[key];
        if (catKey && categories[catKey]) {
          const resArr = custom[key];
          if (Array.isArray(resArr)) {
            for (const resp of resArr) {
              if (resp && !categories[catKey].responses.includes(resp)) {
                categories[catKey].responses.push(resp);
              }
            }
          }
        }
      }
    }

    // Immediately populate the built‚Äëin categories with any user‚Äëdefined
    // responses stored in localStorage.  This ensures custom responses
    // are available before the first interaction.  The call is placed
    // here so it executes during script evaluation.
    loadCustomResponsesIntoCategories();
    // === Multilingual and feedback enhancements ===
    // Determine current language from storage or default to German.  This can be changed via the settings panel.
    let currentLanguage = 'de';
    // Translation dictionary for user interface and messages.  Each language has its own set of labels.
    const translations = {
      de: {
        placeholder: 'Sag etwas...',
        sendButton: 'Senden',
        speechTitle: 'Spracheingabe starten',
        yes: 'Ja',
        no: 'Nein',
        correctRecognition: 'War das korrekt erkannt?',
        selectCorrectEmotion: 'Bitte w√§hle die richtige Emotion:',
        confirm: 'Best√§tigen',
        thankYouLearned: 'Danke! Ich habe gelernt.',
        feedbackPrompt: 'Was habe ich falsch verstanden?',
        errorConfusion: (c, p) => `Ich verwechsle oft ${c} mit ${p}. Danke, dass du mir hilfst!`,
        improvedMessage: 'Diesen Satz habe ich beim ersten Mal falsch eingesch√§tzt. Jetzt erkenne ich ihn besser!',
        emotionalFeedback: 'Ich merke, dass ich dich oft missverstehe‚Ä¶ bitte gib mir noch eine Chance.',
        statsNoData: 'Vorhersage-Statistik: keine Daten',
        statsPrefix: 'Vorhersage-Statistik: ',
        statsCorrect: 'richtig',
        statsWrong: 'falsch',
        learnedExamples: 'Gelernte Beispiele: ',
        emotionPointsLabel: 'Emotionspunkte',
        settingsBtn: '‚öôÔ∏è Einstellungen',
        infoBtn: '‚ÑπÔ∏è Info',
        clearChatBtn: 'Chatverlauf l√∂schen',
        downloadModelBtn: 'Modell herunterladen',
        setDefaultEmotionBtn: 'Festlegen',
        defaultEmotionLabel: 'Standard Emotion:',
        choose: 'W√§hlen‚Ä¶',
        customResponseLabel: 'Eigene Antwort f√ºr Emotion:',
        customResponsePlaceholder: 'Eigene Antwort‚Ä¶',
        addCustomResponseBtn: 'Antwort hinzuf√ºgen',
        languageLabel: 'Sprache:',
        languageOptions: { de:'Deutsch', en:'English' },
        settingsTitle: 'Einstellungen',
        settingsIntro: 'Passe EgoMorph mit wenigen Klicks an ‚Äì von schnellen Aktionen bis zur pers√∂nlichen Ansprache.',
        quickActionsTitle: 'Schnellaktionen',
        quickActionsHint: 'Steuere Verlauf, Stimme und gespeicherte Daten direkt von hier.',
        ltmExportBtn: 'Speichern',
        ltmClearBtn: 'L√∂schen',
        defaultSectionTitle: 'Standardwerte',
        defaultSectionHint: 'Diese Auswahl bestimmt den Ausgangston der Unterhaltung.',
        personalSectionTitle: 'Pers√∂nliche Ansprache',
        userNameLabel: 'Dein Name',
        userNamePlaceholder: 'z. B. Pascal',
        saveUserNameBtn: 'Speichern',
        clearUserNameBtn: 'L√∂schen',
        clearUserNameTitle: 'Name entfernen',
        personalSectionHint: 'EgoMorph spricht dich in Antworten mit diesem Namen an.',
        customSectionTitle: 'Eigene Antworten',
        customSectionDescription: 'Erg√§nze individuelle Reaktionen f√ºr bestimmte Emotionen.',
        appearanceSectionTitle: 'Erscheinung',
        shapeLabel: 'Form',
        shapeOptions: { circle: 'Kreis', square: 'Viereck', triangle: 'Dreieck' },
        pupilLabel: 'Pupillenfarbe',
        pupilOptions: { black: 'Schwarz', blue: 'Blau', yellow: 'Gelb', green: 'Gr√ºn' },
        applyAppearanceBtn: '√úbernehmen',
        languageSectionTitle: 'Sprache',
        savedNameTemplate: '(gespeichert: {name})',
        empathyHighPrefix: 'Ich verstehe dich. ',
        lowTrustSuffix: ' Bist du sicher?',
        emotionComments: {
          freude: 'Du klingst fr√∂hlich',
          wut: 'Es klingt, als w√§rst du w√ºtend',
          traurigkeit: 'Ich sp√ºre Traurigkeit in deinen Worten'
        },
        emotionSummarySingle: 'Ich nehme vor allem {emotion} wahr.',
        emotionSummaryPair: 'Ich nehme {primary} und auch {secondary} wahr.',
        emotionLabels: {
          freude: 'Freude',
          wut: 'Wut',
          traurigkeit: 'Traurigkeit'
        },
        questionIntros: {
          why: 'Du fragst nach dem Warum ‚Äì lass uns das gemeinsam beleuchten.',
          how: 'Ich √ºberlege mit dir, wie das gelingen kann.',
          what: 'Ich schaue, was dir dabei helfen k√∂nnte.',
          when: 'Wir k√∂nnen auch √ºber das richtige Timing sprechen.',
          where: 'Lass uns den passenden Rahmen finden.',
          general: 'Ich denke laut mit dir, damit wir eine Antwort finden.'
        },
        memoryRecallTemplate: 'Ich erinnere mich daran, dass du einmal ‚Äû{memory}‚Äú erw√§hnt hast.',
        topicRecallTemplate: 'Das kn√ºpft an {topic} an, was du vorhin erw√§hnt hast.',
        mentionsObject: 'Du erw√§hnst {object}',
        defaultEmotionOptions: {
          freude:'Freude',
          wut:'Wut',
          traurigkeit:'Traurigkeit',
          angst:'Angst',
          vertrauen:'Vertrauen',
          ueberraschung:'√úberraschung'
        },
        infoText: 'EgoMorph ist ein interaktives Projekt, das mit Liebe und Neugier auf die Erforschung von Emotionen und maschinellem Lernen entstanden ist.Datenschutz:<br>Egomorph Speichert deinen Namen und deine Unterhaltungen,Nur lokal auf deinem Ger√§t. ',
        memoryPrefix: 'Ich erinnere mich an:',
        youPrefix: 'Du:',
        alternativeBtn: 'Diese Antwort w√§re besser gewesen.',
        voiceActivate: 'Stimme aktivieren',
        voiceDeactivate: 'Stimme deaktivieren'
      },
      en: {
        placeholder: 'Say something...',
        sendButton: 'Send',
        speechTitle: 'Start voice input',
        yes: 'Yes',
        no: 'No',
        correctRecognition: 'Was that recognized correctly?',
        selectCorrectEmotion: 'Please select the correct emotion:',
        confirm: 'Confirm',
        thankYouLearned: "Thank you! I've learned.",
        feedbackPrompt: 'What did I misunderstand?',
        errorConfusion: (c, p) => `I often confuse ${c} with ${p}. Thank you for helping me!`,
        improvedMessage: 'I misjudged this sentence the first time. Now I recognize it better!',
        emotionalFeedback: 'I realize that I often misunderstand you... please give me another chance.',
        statsNoData: 'Prediction statistics: no data',
        statsPrefix: 'Prediction statistics: ',
        statsCorrect: 'correct',
        statsWrong: 'wrong',
        learnedExamples: 'Learned examples: ',
        emotionPointsLabel: 'Emotion points',
        settingsBtn: '‚öôÔ∏è Settings',
        infoBtn: '‚ÑπÔ∏è Info',
        clearChatBtn: 'Delete chat history',
        downloadModelBtn: 'Download model',
        setDefaultEmotionBtn: 'Set',
        defaultEmotionLabel: 'Default emotion:',
        choose: 'Select...',
        customResponseLabel: 'Custom response for emotion:',
        customResponsePlaceholder: 'Custom response...',
        addCustomResponseBtn: 'Add response',
        languageLabel: 'Language:',
        languageOptions: { de:'German', en:'English' },
        settingsTitle: 'Settings',
        settingsIntro: 'Adjust EgoMorph in just a few clicks‚Äîfrom quick actions to personalised addressing.',
        quickActionsTitle: 'Quick actions',
        quickActionsHint: 'Control history, voice and stored data right here.',
        ltmExportBtn: 'Save',
        ltmClearBtn: 'Delete',
        defaultSectionTitle: 'Defaults',
        defaultSectionHint: 'This choice defines the initial tone of the conversation.',
        personalSectionTitle: 'Personal address',
        userNameLabel: 'Your name',
        userNamePlaceholder: 'e.g. Pascal',
        saveUserNameBtn: 'Save',
        clearUserNameBtn: 'Remove',
        clearUserNameTitle: 'Remove name',
        personalSectionHint: 'EgoMorph will address you with this name in its replies.',
        customSectionTitle: 'Custom responses',
        customSectionDescription: 'Add individual reactions for specific emotions.',
        appearanceSectionTitle: 'Appearance',
        shapeLabel: 'Shape',
        shapeOptions: { circle: 'Circle', square: 'Square', triangle: 'Triangle' },
        pupilLabel: 'Pupil colour',
        pupilOptions: { black: 'Black', blue: 'Blue', yellow: 'Yellow', green: 'Green' },
        applyAppearanceBtn: 'Apply',
        languageSectionTitle: 'Language',
        savedNameTemplate: '(saved: {name})',
        empathyHighPrefix: 'I understand you. ',
        lowTrustSuffix: ' Are you sure?',
        emotionComments: {
          freude: 'You sound happy',
          wut: 'It sounds like you are angry',
          traurigkeit: 'I sense sadness in your words'
        },
        emotionSummarySingle: 'I mainly sense {emotion}.',
        emotionSummaryPair: 'I sense {primary} and also {secondary}.',
        emotionLabels: {
          freude: 'Joy',
          wut: 'Anger',
          traurigkeit: 'Sadness'
        },
        questionIntros: {
          why: 'You are wondering why ‚Äì let me think it through with you.',
          how: 'Let us explore how that could work.',
          what: 'I am looking at what could support you.',
          when: 'We can talk about the right timing as well.',
          where: 'Let us find the right place or context together.',
          general: 'I will think along with you so we can figure it out.'
        },
        memoryRecallTemplate: 'I remember you once mentioned ‚Äú{memory}‚Äù.',
        topicRecallTemplate: 'That connects to {topic} you mentioned earlier.',
        mentionsObject: 'You mention {object}',
        defaultEmotionOptions: {
          freude:'Joy',
          wut:'Anger',
          traurigkeit:'Sadness',
          angst:'Fear',
          vertrauen:'Trust',
          ueberraschung:'Surprise'
        },
        infoText: 'EgoMorph is an interactive project created with love and curiosity for exploring emotions and machine learning. This placeholder text can later be replaced with information about the origins, ideas and philosophy of EgoMorph.',
        memoryPrefix: 'I remember:',
        youPrefix: 'You:',
        alternativeBtn: 'This answer would have been better.',
        voiceActivate: 'Enable voice',
        voiceDeactivate: 'Disable voice'
      }
    };
    window.__egoTranslations = translations;

    function formatSavedNameLabel(name) {
      if (!name) return '';
      const template = translations[currentLanguage] && translations[currentLanguage].savedNameTemplate;
      if (!template) return name;
      return template.replace('{name}', name);
    }
    window.formatSavedNameLabel = formatSavedNameLabel;

    function renderSavedUserNameLabel() {
      const outEl = document.getElementById('currentUserName');
      if (!outEl) return;
      let saved = '';
      try {
        saved = localStorage.getItem('egoUserName') || '';
      } catch (err) {
        saved = '';
      }
      outEl.textContent = saved ? formatSavedNameLabel(saved) : '';
    }
    window.renderSavedUserNameLabel = renderSavedUserNameLabel;
    // Extend translations with new keys for feedback system and language switching
    translations.de.correctEmotionPrompt = 'Bitte w√§hle die richtige Emotion:';
    translations.en.correctEmotionPrompt = 'Please select the correct emotion:';
    translations.de.commentPrompt = 'Was habe ich falsch verstanden?';
    translations.en.commentPrompt = 'What did I misunderstand?';
    translations.de.confirmFeedback = 'Best√§tigen';
    translations.en.confirmFeedback = 'Confirm';
    translations.de.trainingAcknowledgement = 'Danke! Ich habe gelernt.';
    translations.en.trainingAcknowledgement = 'Thanks! I have learned.';
    translations.de.errorConfuse = 'Ich verwechsle oft {correct} mit {predicted}. Danke, dass du mir hilfst!';
    translations.en.errorConfuse = 'I often confuse {correct} with {predicted}. Thank you for helping me!';
    translations.de.learningProgress = 'Diesen Satz habe ich beim ersten Mal falsch eingesch√§tzt. Jetzt erkenne ich ihn besser!';
    translations.en.learningProgress = 'I misclassified this sentence the first time. Now I recognise it better!';
    translations.de.suggestionsIntro = 'Alternative Vorschl√§ge:';
    translations.en.suggestionsIntro = 'Alternative suggestions:';

    // Add installation button labels for the PWA installer
    translations.de.installBtn = 'Installieren';
    translations.en.installBtn = 'Install';
    // Names of the categories shown to the user for each language
    const categoryDisplayNames = {
      de: {
        dislike:'Nicht m√∂gen',
        greeting:'Begr√º√üung',
        farewell:'Abschied',
        anger:'Wut',
        sadness:'Traurigkeit',
        joy:'Freude',
        fear:'Angst',
        surprise:'√úberraschung',
        trust:'Vertrauen',
        default:'Neutral'
      },
      en: {
        dislike:'Dislike',
        greeting:'Greeting',
        farewell:'Farewell',
        anger:'Anger',
        sadness:'Sadness',
        joy:'Joy',
        fear:'Fear',
        surprise:'Surprise',
        trust:'Trust',
        default:'Neutral'
      }
    };
    // Objects for tracking feedback and personalised learning
    let misclassificationCounts = {};
    let trainingHistory = {};
    let feedbackComments = [];
    let consecutiveWrong = 0;

    // Track how often the anger category has been triggered in a row.  If the
    // user‚Äôs inputs repeatedly elicit angry responses, EgoMorph will enter
    // an evil mode.  Friendly categories reset this counter and return
    // EgoMorph to its normal state.  Evil mode is signalled via the
    // `evil` CSS class on the entity element.
    let angerStreak = 0;
    let evilMode = false;
    // Load persisted variables from localStorage, if available
    (function loadPersistentData() {
      try {
        // current language preference
        const storedLang = localStorage.getItem('currentLanguage');
        if (storedLang && (storedLang === 'de' || storedLang === 'en')) {
          currentLanguage = storedLang;
        }
        const misStr = localStorage.getItem('misclassificationCounts');
        if (misStr) {
          misclassificationCounts = JSON.parse(misStr);
        }
        const trainStr = localStorage.getItem('trainingHistory');
        if (trainStr) {
          trainingHistory = JSON.parse(trainStr);
        }
        const commentsStr = localStorage.getItem('feedbackComments');
        if (commentsStr) {
          feedbackComments = JSON.parse(commentsStr);
        }
      } catch (e) {
        console.warn('Failed to load persisted feedback data', e);
      }
    })();
    // Persist feedback-related data to localStorage
    window.__egoCurrentLanguage = currentLanguage;
    function savePersistentData() {
      try {
        localStorage.setItem('currentLanguage', currentLanguage);
        localStorage.setItem('misclassificationCounts', JSON.stringify(misclassificationCounts));
        localStorage.setItem('trainingHistory', JSON.stringify(trainingHistory));
        localStorage.setItem('feedbackComments', JSON.stringify(feedbackComments));
      } catch (e) {
        console.warn('Failed to save persisted feedback data', e);
      }
    }
    // Synonyms mapping for retraining on similar expressions
    const synonymsMapping = {
      'so fertig': ['ich kann nicht mehr','ich bin ersch√∂pft'],
      'ich bin so fertig': ['ich kann nicht mehr','ich bin ersch√∂pft'],
      'traurig': ['bedr√ºckt','depressiv'],
      'w√ºtend': ['sauer','ver√§rgert'],
      'gl√ºcklich': ['fr√∂hlich','zufrieden'],
      'angst': ['furcht','panik','sorge'],
      'freue': ['gl√ºcklich','freudig'],
      'liebe': ['mag','sch√§tze'],
      'einsam': ['allein'],
      'm√ºde': ['ersch√∂pft','kaputt']
    };
    // Preserve the original German responses for each category to support language switching
    const originalResponses = {};
    for (const k in categories) {
      originalResponses[k] = categories[k].responses.slice();
    }
    // Provide English alternatives for the category responses
    const categoriesEnglish = {
      dislike: { responses: ["That hurts me. You don't like me?", "It's a pity you don't like me. That hurts.", "So hard to hear that you don't like me."] },
      greeting: { responses: ['Hello! How are you?', 'Hi! Nice that you are here.', "Hey! I'm glad to hear from you."] },
      farewell: { responses: ['Goodbye. See you next time!', 'Bye! I hope we see each other again.', 'See you soon. Take care!'] },
      anger: { responses: ['These words hurt me and make me angry.', 'I feel the anger rising within me.', 'Why so much anger? That hurts me.'] },
      sadness: { responses: ["It sounds like you're very sad. That makes me sad too.", 'I feel your sorrow. You are not alone.', 'That hurts me. Why do you feel that way?'] },
      joy: { responses: ['That makes me happy! Thank you for being so kind.', 'I feel joy‚Äîyour words give me strength.', 'So much positivity! That feels good.'] },
      fear: { responses: ['I feel insecurity and fear. It unsettles me.', 'Your words scare me. What will happen?', 'I feel threatened and uncertain.'] },
      surprise: { responses: ["Oh! I didn't expect that.", 'That surprises me a lot!', 'I would not have expected that.'] },
      trust: { responses: ['I feel your trust. That means a lot to me.', 'Thank you for your trust‚Äîit strengthens us.', 'I feel safe with you.'] },
      default: { responses: ["I'm listening to you. Tell me more.", 'Interesting... Please continue.', 'Thank you for sharing your thoughts with me.'] }
    };

    /**
     * Basic sentiment analysis to count positive and negative tokens and
     * derive per-category counts.  Negations flip the sentiment of
     * following tokens.
     */
    function analyseSentiment(text) {
      const cleaned = text.toLowerCase().replace(/[.,!?]/g, ' ');
      const tokens = cleaned.split(/\s+/).filter(Boolean);
      let positive = 0, negative = 0;
      let angerCount = 0, sadnessCount = 0, fearCount = 0, joyCount = 0;
      for (let i = 0; i < tokens.length; i++) {
        const word = tokens[i];
        if ((word === 'nicht' || word === 'kein') && i < tokens.length - 1) {
          const next = tokens[i + 1];
          if (positiveWords.includes(next)) {
            negative++;
            i++;
            continue;
          } else if (negativeWords.includes(next)) {
            positive++;
            joyCount++;
            i++;
            continue;
          }
        }
        if (positiveWords.includes(word)) {
          positive++;
          if (angerWords.includes(word)) angerCount++;
          if (sadnessWords.includes(word)) sadnessCount++;
          if (fearWords.includes(word)) fearCount++;
          if (joyWords.includes(word)) joyCount++;
        } else if (negativeWords.includes(word)) {
          negative++;
          if (angerWords.includes(word)) angerCount++;
          if (sadnessWords.includes(word)) sadnessCount++;
          if (fearWords.includes(word)) fearCount++;
          if (joyWords.includes(word)) joyCount++;
        }
      }
      return { positive, negative, angerCount, sadnessCount, fearCount, joyCount };
    }
    /**
     * Determine the most appropriate category for a given input.  Uses
     * keyword counts and sentiment to select the best match.  If no
     * keywords match, returns 'default'.  This function does not
     * incorporate the TensorFlow.js model ‚Äì that is handled in the
     * interact() function below so that asynchronous predictions can
     * influence the final decision.
     */
    function detectCategory(text) {
      const lower = text.toLowerCase();
      // Special case: explicit dislike of EgoMorph.
      if (/\bmag\s+dich\s+nicht\b/.test(lower)) return 'dislike';
      if (!lower.trim()) return 'default';
      let best = 'default';
      let maxCount = 0;
      for (const key in categories) {
        if (key === 'default') continue;
        const { keywords } = categories[key];
        let count = 0;
        for (const kw of keywords) {
          if (lower.includes(kw)) count++;
        }
        if (count > maxCount) {
          maxCount = count;
          best = key;
        }
      }
      const sentiment = analyseSentiment(text);
      if (maxCount === 0) {
        if (sentiment.positive > sentiment.negative + 1) {
          return 'joy';
        } else if (sentiment.negative > sentiment.positive + 1) {
          const negCounts = [
            { name: 'anger', count: sentiment.angerCount },
            { name: 'sadness', count: sentiment.sadnessCount },
            { name: 'fear', count: sentiment.fearCount }
          ];
          negCounts.sort((a, b) => b.count - a.count);
          return negCounts[0].count > 0 ? negCounts[0].name : 'sadness';
        }
      }
      if (maxCount > 0) {
        const negativeCats = ['anger','sadness','fear'];
        const positiveCats = ['joy','trust'];
        if (sentiment.positive > sentiment.negative + 1 && negativeCats.includes(best)) {
          return 'joy';
        }
        if (sentiment.negative > sentiment.positive + 1 && positiveCats.includes(best)) {
          const negCounts = [
            { name: 'anger', count: sentiment.angerCount },
            { name: 'sadness', count: sentiment.sadnessCount },
            { name: 'fear', count: sentiment.fearCount }
          ];
          negCounts.sort((a, b) => b.count - a.count);
          return negCounts[0].count > 0 ? negCounts[0].name : 'sadness';
        }
        return best;
      }
      return 'default';
    }

    /**
     * Render the entity's appearance based on current emotions.  Colour
     * and scale follow the dominant emotion.  The face (eyes and
     * mouth) adjusts expression accordingly.
     */
    function renderEntity() {
      const { wut, vertrauen, freude, angst, traurigkeit, ueberraschung } = emotion;
      let dominant = 'wut';
      let maxValue = wut;
      const emotions = { vertrauen, freude, angst, traurigkeit, ueberraschung };
      for (const name in emotions) {
        if (emotions[name] > maxValue) {
          dominant = name;
          maxValue = emotions[name];
        }
      }
      let colour;
      switch (dominant) {
        case 'wut': colour = '#f33'; break;
        case 'freude': colour = '#6f6'; break;
        case 'angst': colour = '#f93'; break;
        case 'traurigkeit': colour = '#33a'; break;
        case 'vertrauen': colour = '#ff3'; break;
        case 'ueberraschung': colour = '#c6f'; break;
        default: colour = '#66f';
      }
      // Decay surprise slowly.
      emotion.ueberraschung = clamp(emotion.ueberraschung - 5);
      const positive = freude + vertrauen;
      const negative = wut + angst + traurigkeit;
      let scale = 1 + (positive - negative) / 300;
      // Incorporate energy from the personality core into the scale. A
      // higher energy makes the entity larger and more animated.
      if (typeof personality !== 'undefined') {
        scale *= 0.8 + 0.4 * personality.energy;
      }
      scale = Math.max(0.7, Math.min(1.5, scale));
      entity.style.background = `radial-gradient(circle at center, ${colour}, #111)`;
      entity.style.boxShadow = `0 0 40px ${colour}`;
      // Update the scale CSS variable instead of directly setting transform.
      // This allows the shake animation (which also uses transform) to
      // incorporate the scaling without conflict.  See the CSS rules for
      // #entity and @keyframes shake.
      entity.style.setProperty('--scale', scale);
      // Apply a shaking animation when anger ('wut') is the dominant emotion.
      if (dominant === 'wut') {
        entity.classList.add('shake');
      } else {
        entity.classList.remove('shake');
      }
      leftEye.style.width = rightEye.style.width = '20%';
      leftEye.style.background = rightEye.style.background = '#eee';
      let eyeHeight;
      mouth.style.border = 'none';
      mouth.style.borderRadius = '0';
      mouth.style.height = '10%';
      mouth.style.width = '50%';
      mouth.style.left = '25%';
      mouth.style.bottom = '25%';
      mouth.style.top = '';
      let borderColor = colour;
      switch (dominant) {
        case 'freude':
          eyeHeight = '22%';
          mouth.style.border = `4px solid ${borderColor}`;
          mouth.style.borderTop = 'none';
          mouth.style.borderRadius = '0 0 50% 50%';
          mouth.style.height = '20%';
          break;
        case 'wut':
          eyeHeight = '12%';
          mouth.style.border = `4px solid ${borderColor}`;
          mouth.style.borderBottom = 'none';
          mouth.style.borderRadius = '50% 50% 0 0';
          mouth.style.height = '15%';
          break;
        case 'traurigkeit':
          eyeHeight = '15%';
          mouth.style.border = `4px solid ${borderColor}`;
          mouth.style.borderBottom = 'none';
          mouth.style.borderRadius = '50% 50% 0 0';
          mouth.style.height = '18%';
          break;
        case 'angst':
          eyeHeight = '25%';
          mouth.style.border = `4px solid ${borderColor}`;
          mouth.style.borderRadius = '50%';
          mouth.style.height = '28%';
          break;
        case 'ueberraschung':
          eyeHeight = '28%';
          mouth.style.border = `4px solid ${borderColor}`;
          mouth.style.borderRadius = '50%';
          mouth.style.height = '32%';
          break;
        case 'vertrauen':
          eyeHeight = '20%';
          mouth.style.border = `3px solid ${borderColor}`;
          mouth.style.borderTop = 'none';
          mouth.style.borderRadius = '0 0 50% 50%';
          mouth.style.height = '18%';
          break;
        default:
          eyeHeight = '18%';
          mouth.style.border = `3px solid ${borderColor}`;
          mouth.style.borderTop = 'none';
          mouth.style.borderBottom = 'none';
          mouth.style.height = '8%';
          break;
      }
      leftEye.style.height = rightEye.style.height = eyeHeight;
      // After updating the appearance, persist the current emotion vector to
      // localStorage.  Storing the full emotion object allows EgoMorph to
      // restore the same mood and facial colour on page reloads.  Wrap
      // access in a try/catch to silently ignore quota or privacy errors.
      try {
        localStorage.setItem('egoEmotion', JSON.stringify(emotion));
      } catch (err) {
        // Ignore errors when localStorage is unavailable or blocked
      }

      // When the evil flag is set, override the facial features to create
      // a menacing appearance.  Inline styles here take precedence over
      // earlier assignments.  The eyes become narrower and tinted, the
      // pupils darken and the mouth flips into a frown.  When evilMode
      // is false, reset any overrides on the pupils so the CSS variable
      // --pupil-color controls their colour again.
      if (typeof evilMode !== 'undefined' && evilMode) {
        // Adjust eyes: narrower height and reddish sclera
        leftEye.style.height = rightEye.style.height = '12%';
        leftEye.style.background = '#fcc';
        rightEye.style.background = '#fcc';
        // Dark pupils
        if (typeof leftPupil !== 'undefined' && leftPupil) {
          leftPupil.style.background = '#600';
        }
        if (typeof rightPupil !== 'undefined' && rightPupil) {
          rightPupil.style.background = '#600';
        }
        // Frowning mouth
        mouth.style.border = '4px solid #b00';
        mouth.style.borderBottom = 'none';
        mouth.style.borderRadius = '50% 50% 0 0';
        mouth.style.height = '20%';
      } else {
        // Reset pupil background so it can be controlled via CSS
        if (typeof leftPupil !== 'undefined' && leftPupil) {
          leftPupil.style.background = '';
        }
        if (typeof rightPupil !== 'undefined' && rightPupil) {
          rightPupil.style.background = '';
        }
      }
    }
    /**
     * Text-to-speech using Web Speech API, with pitch/rate modulated by
     * dominant emotion.
     */
    function speak(text) {
      // If voice output is disabled or unavailable, abort early.
      if (!voiceEnabled) return;
      if (typeof window === 'undefined' || !('speechSynthesis' in window)) return;
      if (!text) return;
      const synth = window.speechSynthesis;
      // Cancel any ongoing utterances to avoid overlapping playback
      synth.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      // Determine the dominant emotion to modulate pitch and rate
      const { wut, vertrauen, freude, angst, traurigkeit, ueberraschung } = emotion;
      let dominantName = 'wut';
      let dominantValue = wut;
      const emotionMap = { vertrauen, freude, angst, traurigkeit, ueberraschung };
      for (const name in emotionMap) {
        if (emotionMap[name] > dominantValue) {
          dominantName = name;
          dominantValue = emotionMap[name];
        }
      }
      switch (dominantName) {
        case 'freude': utterance.pitch = 1.3; utterance.rate = 1.0; break;
        case 'vertrauen': utterance.pitch = 1.1; utterance.rate = 0.95; break;
        case 'wut': utterance.pitch = 0.8; utterance.rate = 0.9; break;
        case 'traurigkeit': utterance.pitch = 0.7; utterance.rate = 0.85; break;
        case 'angst': utterance.pitch = 0.9; utterance.rate = 0.9; break;
        case 'ueberraschung': utterance.pitch = 1.5; utterance.rate = 1.1; break;
        default: utterance.pitch = 1.0; utterance.rate = 1.0;
      }
      // Modify pitch and rate based on personality traits, if available
      if (typeof personality !== 'undefined') {
        utterance.rate *= Math.max(0.5, Math.min(1.5, personality.energy));
        utterance.pitch *= 1 + (personality.empathyLevel - 0.5) * 0.4;
      }
      // Helper to assign a suitable voice and speak the utterance.  If the
      // list of available voices is empty (common on first invocation),
      // wait for the 'voiceschanged' event before selecting a voice.  This
      // prevents silent playback on some browsers.
      function assignVoiceAndSpeak() {
        const voices = synth.getVoices();
        if (voices && voices.length > 0) {
          // Prefer a German voice when available; otherwise fall back to the first voice.
          const deVoices = voices.filter(v => v.lang && v.lang.toLowerCase().startsWith('de'));
          utterance.voice = deVoices.length ? deVoices[0] : voices[0];
        }
        synth.speak(utterance);
      }
      // If voices are not yet loaded, defer speaking until the voices list is ready.
      if (!synth.getVoices().length) {
        synth.addEventListener('voiceschanged', assignVoiceAndSpeak, { once: true });
      } else {
        assignVoiceAndSpeak();
      }
    }

    // === Personality core and feedback management ===
    // This object tracks EgoMorph's internal personality state. Values change over time.
    const personality = {
      empathyLevel: 0.5, // between 0 and 1; higher values lead to more empathetic responses
      moodBias: 'neutral', // can be 'neutral', 'traurig' or 'aufgebracht'
      trust: 1.0, // from 0 to 1; decreases when user indicates wrong classification
      energy: 1.0 // from 0.3 to 1.5; controls response length and speech speed
    };
    // Statistics to track how often the classifier is correct/incorrect.
    const predictionStats = { correct: 0, wrong: 0 };
    // Variables to remember the last prediction and input for feedback.
    let lastPredictedCategory = null;
    let lastInputText = '';
    // Store the last predicted emotion distribution so that replies can reference it.
    let lastEmotionResults = null;
    // Count of user-provided training examples.  This reflects how many times
    // the user has corrected a classification.  Retrieved from localStorage on load.
    let userTrainingCount = 0;
    /**
     * Update the visible statistics display in the UI.
     */
    function updateStatsDisplay() {
      const total = predictionStats.correct + predictionStats.wrong;
      const statsEl = document.getElementById('stats');
      if (!statsEl) return;
      let text = '';
      if (total > 0) {
        const correctPct = Math.round((predictionStats.correct / total) * 100);
        const wrongPct = 100 - correctPct;
        text = translations[currentLanguage].statsPrefix + correctPct + '% ' + translations[currentLanguage].statsCorrect + ', ' + wrongPct + '% ' + translations[currentLanguage].statsWrong;
      } else {
        // When no predictions have been made yet, provide a baseline text.
        text = translations[currentLanguage].statsNoData;
      }
      // Append the number of learned examples so users can see progress.
      if (userTrainingCount > 0) {
        text += '; ' + translations[currentLanguage].learnedExamples + userTrainingCount;
      }
      statsEl.textContent = text;
    }

    /**
     * Update all visible UI elements to match the currently selected language.  This function
     * updates labels, button texts, placeholders and informational text.  It should be
     * called whenever currentLanguage changes or after restoring settings from storage.
     */
    function updateUIForLanguage() {
      // Input placeholder
      if (input) {
        input.placeholder = translations[currentLanguage].placeholder;
      }
      // Send button
      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) {
        sendBtn.textContent = translations[currentLanguage].sendButton;
      }
      // Speech button title
      if (speechButton) {
        speechButton.title = translations[currentLanguage].speechTitle;
      }
      // Settings and info toggle buttons
      const settingsToggleEl = document.getElementById('settingsToggle');
      if (settingsToggleEl) {
        settingsToggleEl.textContent = translations[currentLanguage].settingsBtn;
      }
      const infoToggleEl = document.getElementById('infoToggle');
      if (infoToggleEl) {
        infoToggleEl.textContent = translations[currentLanguage].infoBtn;
      }
      // Clear chat, download model and default emotion buttons
      const settingsTitleEl = document.getElementById('settingsTitle');
      if (settingsTitleEl) {
        settingsTitleEl.textContent = translations[currentLanguage].settingsTitle;
      }
      const settingsIntroEl = document.getElementById('settingsIntro');
      if (settingsIntroEl) {
        settingsIntroEl.textContent = translations[currentLanguage].settingsIntro;
      }
      const quickSummaryEl = document.getElementById('settingsQuickSummary');
      if (quickSummaryEl) {
        quickSummaryEl.textContent = translations[currentLanguage].quickActionsTitle;
      }
      const quickHintEl = document.getElementById('quickActionsHint');
      if (quickHintEl) {
        quickHintEl.textContent = translations[currentLanguage].quickActionsHint;
      }
      const ltmExportEl = document.getElementById('ltmExportBtn');
      if (ltmExportEl) {
        ltmExportEl.textContent = translations[currentLanguage].ltmExportBtn;
      }
      const ltmClearEl = document.getElementById('ltmClearBtn');
      if (ltmClearEl) {
        ltmClearEl.textContent = translations[currentLanguage].ltmClearBtn;
    }
      const clearBtnEl = document.getElementById('clearConvBtn');
      if (clearBtnEl) {
        clearBtnEl.textContent = translations[currentLanguage].clearChatBtn;
      }
      const downloadEl = document.getElementById('downloadModelBtn');
      if (downloadEl) {
        downloadEl.textContent = translations[currentLanguage].downloadModelBtn;
      }
      const setDefEl = document.getElementById('setDefaultEmotionBtn');
      if (setDefEl) {
        setDefEl.textContent = translations[currentLanguage].setDefaultEmotionBtn;
      }
      // Voice toggle button text depends on state
      const toggleVoiceEl = document.getElementById('toggleVoiceBtn');
      if (toggleVoiceEl) {
        if (voiceEnabled) {
          toggleVoiceEl.textContent = translations[currentLanguage].voiceDeactivate;
        } else {
          toggleVoiceEl.textContent = translations[currentLanguage].voiceActivate;
        }
      }
      // Labels for default emotion and custom response
      const defaultLabelEl = document.getElementById('defaultEmotionLabel');
      if (defaultLabelEl) {
        defaultLabelEl.textContent = translations[currentLanguage].defaultEmotionLabel;
      }

      const defaultSummaryEl = document.getElementById('settingsDefaultSummary');
      if (defaultSummaryEl) {
        defaultSummaryEl.textContent = translations[currentLanguage].defaultSectionTitle;
      }
      const defaultHintEl = document.getElementById('defaultEmotionHint');
      if (defaultHintEl) {
        defaultHintEl.textContent = translations[currentLanguage].defaultSectionHint;
      }
      const customLabelEl = document.getElementById('customResponseLabel');
      if (customLabelEl) {
        customLabelEl.textContent = translations[currentLanguage].customResponseLabel;
      }
      const customSummaryEl = document.getElementById('customSummary');
      if (customSummaryEl) {
        customSummaryEl.textContent = translations[currentLanguage].customSectionTitle;
      }
      const customDescriptionEl = document.getElementById('customDescription');
      if (customDescriptionEl) {
        customDescriptionEl.textContent = translations[currentLanguage].customSectionDescription;
      }
      // Placeholder for custom response input
      const customInputEl = document.getElementById('customResponseInput');
      if (customInputEl) {
        customInputEl.placeholder = translations[currentLanguage].customResponsePlaceholder;
      }
      // Button for adding custom response
      const addCustomEl = document.getElementById('addCustomResponseBtn');
      if (addCustomEl) {
        addCustomEl.textContent = translations[currentLanguage].addCustomResponseBtn;
      }
      // Label for language selection
      const langLabelEl = document.getElementById('languageLabel');
      if (langLabelEl) {
        langLabelEl.textContent = translations[currentLanguage].languageLabel;
      }
      const languageSummaryEl = document.getElementById('languageSummary');
      if (languageSummaryEl) {
        languageSummaryEl.textContent = translations[currentLanguage].languageSectionTitle;
    }
      // Update language select options
      const langSelectEl = document.getElementById('languageSelect');
      if (langSelectEl) {
        for (let i = 0; i < langSelectEl.options.length; i++) {
          const optVal = langSelectEl.options[i].value;
          const transLabel = translations[currentLanguage].languageOptions[optVal];
          if (transLabel) langSelectEl.options[i].textContent = transLabel;
        }
        langSelectEl.value = currentLanguage;
      }
      // Default emotion select options
      const defSelect = document.getElementById('defaultEmotionSelect');
      if (defSelect) {
        for (let i = 0; i < defSelect.options.length; i++) {
          const val = defSelect.options[i].value;
          if (!val) {
            defSelect.options[i].textContent = translations[currentLanguage].choose;
          } else {
            const lbl = translations[currentLanguage].defaultEmotionOptions[val];
            if (lbl) defSelect.options[i].textContent = lbl;
          }
        }
      }
      // Custom emotion select options
      const custSelect = document.getElementById('customEmotionSelect');
      if (custSelect) {
        for (let i = 0; i < custSelect.options.length; i++) {
          const val = custSelect.options[i].value;
          const lbl = translations[currentLanguage].defaultEmotionOptions[val];
          if (lbl) custSelect.options[i].textContent = lbl;
        }
      }
      const personalSummaryEl = document.getElementById('settingsPersonalSummary');
      if (personalSummaryEl) {
        personalSummaryEl.textContent = translations[currentLanguage].personalSectionTitle;
      }
      const userNameLabelEl = document.getElementById('userNameLabel');
      if (userNameLabelEl) {
        userNameLabelEl.textContent = translations[currentLanguage].userNameLabel;
      }
      const userNameInputEl = document.getElementById('userNameInput');
      if (userNameInputEl) {
        userNameInputEl.placeholder = translations[currentLanguage].userNamePlaceholder;
      }
      const saveNameBtn = document.getElementById('saveUserNameBtn');
      if (saveNameBtn) {
        saveNameBtn.textContent = translations[currentLanguage].saveUserNameBtn;
      }
      const clearNameBtn = document.getElementById('clearUserNameBtn');
      if (clearNameBtn) {
        clearNameBtn.textContent = translations[currentLanguage].clearUserNameBtn;
        clearNameBtn.title = translations[currentLanguage].clearUserNameTitle;
      }
      const personalHintEl = document.getElementById('personalHint');
      if (personalHintEl) {
        personalHintEl.textContent = translations[currentLanguage].personalSectionHint;
      }
      const appearanceSummaryEl = document.getElementById('appearanceSummary');
      if (appearanceSummaryEl) {
        appearanceSummaryEl.textContent = translations[currentLanguage].appearanceSectionTitle;
      }
      const shapeLabelEl = document.getElementById('shapeLabel');
      if (shapeLabelEl) {
        shapeLabelEl.textContent = translations[currentLanguage].shapeLabel;
      }
      const shapeSelect = document.getElementById('shapeSelect');
      if (shapeSelect) {
        const shapeTranslations = translations[currentLanguage].shapeOptions || {};
        for (let i = 0; i < shapeSelect.options.length; i++) {
          const val = shapeSelect.options[i].value;
          if (shapeTranslations[val]) {
            shapeSelect.options[i].textContent = shapeTranslations[val];
          }
        }
      }
      const pupilLabelEl = document.getElementById('pupilLabel');
      if (pupilLabelEl) {
        pupilLabelEl.textContent = translations[currentLanguage].pupilLabel;
      }
      const pupilSelect = document.getElementById('pupilColorSelect');
      if (pupilSelect) {
        const pupilTranslations = translations[currentLanguage].pupilOptions || {};
        for (let i = 0; i < pupilSelect.options.length; i++) {
          const val = pupilSelect.options[i].value;
          if (pupilTranslations[val]) {
            pupilSelect.options[i].textContent = pupilTranslations[val];
          }
        }
      }
      const applyAppearanceBtn = document.getElementById('applyAppearanceBtn');
      if (applyAppearanceBtn) {
        applyAppearanceBtn.textContent = translations[currentLanguage].applyAppearanceBtn;
      }
      // Update information panel text
      const infoContentEl = document.getElementById('infoContent');
      if (infoContentEl) {
        infoContentEl.textContent = translations[currentLanguage].infoText;
      }
      // Update saved name display with translated text
      renderSavedUserNameLabel();
      // Refresh stats and error messages
      updateStatsDisplay();
      updateErrorStatsMessage();
      if (translations[currentLanguage] && translations[currentLanguage].emotionPointsLabel) {
        emotionPointsLabel = translations[currentLanguage].emotionPointsLabel;
      } else if (currentLanguage === 'en') {
        emotionPointsLabel = 'Emotion points';
      } else {
        emotionPointsLabel = 'Emotionspunkte';
      }
      updateEmotionPointsDisplay();
      // Re-render conversation history so the user label updates
      updateConversation();
    }

    /**
     * Change the user interface language and update all category responses accordingly.
     * When switching to English, replace the current categories' response arrays with
     * their English versions. When switching back to German, restore the original
     * German responses. Persist the selected language to localStorage.
     */
    function changeLanguage(newLang) {
      if (!newLang || (newLang !== 'de' && newLang !== 'en')) return;
      currentLanguage = newLang;
      window.__egoCurrentLanguage = currentLanguage;
      // Switch category responses to the corresponding language.  Original German
      // responses are stored in originalResponses and English versions in categoriesEnglish.
      for (const key in categories) {
        if (newLang === 'en') {
          // Use English responses for the given category if available.
          if (categoriesEnglish[key]) {
            categories[key].responses = categoriesEnglish[key].responses.slice();
          }
        } else {
          // Restore original German responses from backup.
          if (originalResponses[key]) {
            categories[key].responses = originalResponses[key].slice();
          }
        }
      }
      // Persist language selection and refresh UI.
      savePersistentData();
      updateUIForLanguage();
    }
    /**
     * Adapt the reply text based on personality state. This function adds
     * empathetic phrasing, mood or energy related changes to the original reply.
     */
    function adaptReplyBasedOnPersonality(reply) {
      let newReply = reply;
      // High empathy adds an understanding preface.
      if (personality.empathyLevel > 0.7) {
        const prefix = translations[currentLanguage] && translations[currentLanguage].empathyHighPrefix;
        if (prefix) {
          newReply = prefix + newReply;
        } else if (currentLanguage === 'en') {
          newReply = 'I understand you. ' + newReply;
        } else {
          newReply = 'Ich verstehe dich. ' + newReply;
        }
      } else if (personality.empathyLevel < 0.3) {
        // Low empathy might make replies shorter and more curt.
        newReply = newReply.split('.').shift() + '.';
      }
      // Mood bias alters the tone.
      if (personality.moodBias === 'traurig') {
        newReply = newReply + ' üòî';
      } else if (personality.moodBias === 'aufgebracht') {
        newReply = newReply + '!';
      }
      // Energy influences length: low energy yields shorter replies.
      if (personality.energy < 0.7) {
        const words = newReply.split(' ');
        const keep = Math.max(3, Math.floor(words.length * personality.energy));
        newReply = words.slice(0, keep).join(' ');
        if (!/[.!?]$/.test(newReply)) newReply += '‚Ä¶';
      }
      // Low trust makes the entity question the user's statement.
      if (personality.trust < 0.5) {
        const suffix = translations[currentLanguage] && translations[currentLanguage].lowTrustSuffix;
        if (suffix) {
          newReply = newReply + suffix;
        } else if (currentLanguage === 'en') {
          newReply = newReply + ' Are you sure?';
        } else {
          newReply = newReply + ' Bist du sicher?';
        }
      }
      return newReply;
    }

   function detectQuestionType(text) {
      const lower = (text || '').toLowerCase();
      if (!lower) return null;
      const sanitized = lower.replace(/#[\w-]+/g, ' ');
      const hasQuestionMark = sanitized.includes('?');
      if (/\b(warum|weshalb|wieso|why)\b/.test(sanitized)) return 'why';
      if (/\b(wie|how|womit|wodurch)\b/.test(sanitized)) return 'how';
      if (/\b(was|what|welche?r?)\b/.test(sanitized)) return 'what';
      if (/\b(wann|when)\b/.test(sanitized)) return 'when';
      if (/\b(wo|where)\b/.test(sanitized)) return 'where';
      if (hasQuestionMark) return 'general';
      return null;
    }

    function getQuestionIntro(type) {
      if (!type) return '';
      const map = translations[currentLanguage] && translations[currentLanguage].questionIntros;
      if (map && map[type]) return map[type];
      if (map && map.general) return map.general;
      if (currentLanguage === 'en') {
        return 'Let me think that through with you.';
      }
      return 'Lass mich mit dir dar√ºber nachdenken.';
    }

    function buildEmotionSummary(emotionResults) {
      if (!emotionResults) return '';
      const entries = Object.entries(emotionResults)
        .filter(([_, val]) => typeof val === 'number' && val >= 0.1);
      if (!entries.length) return '';
      entries.sort((a, b) => b[1] - a[1]);
      const meaningful = entries.slice(0, 2);
      const labels = (translations[currentLanguage] && translations[currentLanguage].emotionLabels) || {};
      const formatEntry = ([key, val]) => {
        const label = labels[key] || key;
        const safeLabel = escapeHTML(label);
        return safeLabel + ' (' + Math.round(val * 100) + '%)';
      };
      const formatted = meaningful.map(formatEntry);
      if (formatted.length === 0) return '';
      if (formatted.length === 1) {
        const template = translations[currentLanguage] && translations[currentLanguage].emotionSummarySingle;
        if (template) return template.replace('{emotion}', formatted[0]);
        if (currentLanguage === 'en') {
          return 'I sense ' + formatted[0] + '.';
        }
        return 'Ich nehme ' + formatted[0] + ' wahr.';
      }
      const template = translations[currentLanguage] && translations[currentLanguage].emotionSummaryPair;
      if (template) {
        return template.replace('{primary}', formatted[0]).replace('{secondary}', formatted[1]);
      }
      if (currentLanguage === 'en') {
        return 'I sense ' + formatted[0] + ' and ' + formatted[1] + '.';
      }
      return 'Ich nehme ' + formatted[0] + ' und ' + formatted[1] + ' wahr.';
    }

    function buildTopicRecallComment(text) {
      if (!Array.isArray(memory.topics) || memory.topics.length === 0) return '';
      const lower = (text || '').toLowerCase();
      const topics = memory.topics.slice().reverse();
      let match = null;
      for (const topic of topics) {
        if (topic && lower.includes(topic)) {
          match = topic;
          break;
        }
      }
      if (!match || match === lastTopicReference) return '';
      lastTopicReference = match;
      const display = match.charAt(0).toUpperCase() + match.slice(1);
      const safeTopic = escapeHTML(display);
      const template = translations[currentLanguage] && translations[currentLanguage].topicRecallTemplate;
      if (template) return template.replace('{topic}', safeTopic);
      if (currentLanguage === 'en') {
        return 'That reminds me of ' + safeTopic + ' from earlier.';
      }
      return 'Das erinnert mich an ' + safeTopic + ' von vorhin.';
    }

    function buildMemoryRecallComment(text) {
      if (typeof window.queryLongTermMemory !== 'function') return '';
      const raw = (text || '').trim();
      if (!raw) return '';
      const query = raw.replace(/#[\w-]+/g, '').trim() || raw;
      let matches = [];
      try {
        matches = window.queryLongTermMemory(query, 1);
      } catch (err) {
        matches = [];
      }
      if (!Array.isArray(matches) || matches.length === 0) return '';
      const snippet = (matches[0] || '').trim();
      if (!snippet || snippet === lastMemoryReference) return '';
      lastMemoryReference = snippet;
      const safeSnippet = escapeHTML(snippet);
      const template = translations[currentLanguage] && translations[currentLanguage].memoryRecallTemplate;
      if (template) return template.replace('{memory}', safeSnippet);
      if (currentLanguage === 'en') {
        return 'I remember you said ‚Äú' + safeSnippet + '‚Äù before.';
      }
      return 'Ich erinnere mich, dass du ‚Äû' + safeSnippet + '‚Äú gesagt hast.';
              }
        
      /**
     * Generate a smarter reply by incorporating the predicted emotion and SVO
     * of the user's input.  Adds context‚Äësensitive comments about the user's
     * mood and the object they mention.
     *
     * @param {string} text The user's original input.
     * @param {string} reply The base reply after personality adaptation.
     * @param {Object|null} emotionResults Probability distribution over emotions.
     * @returns {Promise<string>} A promise resolving to an enhanced reply.
     */
    async function generateSmartReply(text, reply, emotionResults) {
      try {
        // Determine the dominant predicted emotion if probabilities are available.
        let dominant = null;
        let maxVal = 0;
        if (emotionResults) {
          for (const key in emotionResults) {
            const val = emotionResults[key];
            if (typeof val === 'number' && val > maxVal) {
              dominant = key;
              maxVal = val;
            }
          }
        }
        // Map internal emotion identifiers to human-friendly descriptions.
        const emotionComments = (translations[currentLanguage] && translations[currentLanguage].emotionComments) || {};
        const parts = [];
        if (dominant && emotionComments[dominant]) {
          parts.push(emotionComments[dominant]);
        }
        // Use SVO detection to reference the object mentioned by the user.
        const svo = detectSVO(text);
        if (svo && svo.object) {
          // Escape any HTML characters in the object to avoid injection.
          const obj = escapeHTML(svo.object);
          const mentionTemplate = translations[currentLanguage] && translations[currentLanguage].mentionsObject;
          if (mentionTemplate) {
            parts.push(mentionTemplate.replace('{object}', obj));
          } else {
            const fallback = currentLanguage === 'en' ? 'You mention ' : 'Du erw√§hnst ';
            parts.push(fallback + obj);
          }
        }
        if (parts.length > 0) {
          // Join the contextual comments with periods and append to the reply.
          return reply + ' ' + parts.join('. ') + '.';
        }
        return reply;
      } catch (err) {
        // On any error, fall back to the original reply.
        return reply;
      }
    }

    /**
     * Update the internal personality state based on the predicted category.
     * Sad or angry inputs lower energy and increase empathy, while joyful
     * inputs lighten the mood and reduce empathy. Energy decays over time.
     */
    function updatePersonality(predCat) {
      // Determine mood bias based on category.
      if (predCat === 'sadness') {
        personality.moodBias = 'traurig';
      } else if (predCat === 'anger') {
        personality.moodBias = 'aufgebracht';
      } else if (predCat === 'fear') {
        personality.moodBias = 'aufgebracht';
      } else if (predCat === 'joy' || predCat === 'trust' || predCat === 'greeting' || predCat === 'farewell') {
        personality.moodBias = 'neutral';
      }
      // Empathy adjustments: negative categories increase empathy, joy decreases slightly.
      if (predCat === 'sadness' || predCat === 'anger' || predCat === 'fear') {
        personality.empathyLevel = Math.min(1, personality.empathyLevel + 0.05);
      } else if (predCat === 'joy' || predCat === 'trust') {
        personality.empathyLevel = Math.max(0, personality.empathyLevel - 0.05);
      }
      // Energy decays slightly each interaction and is boosted slightly by joyful interactions.
      personality.energy = Math.max(0.3, personality.energy - 0.03);
      if (predCat === 'joy') {
        personality.energy = Math.min(1.5, personality.energy + 0.05);
      }
    }
    /**
     * Display a feedback prompt asking whether the classification was correct.
     * On 'Ja', update stats. On 'Nein', allow the user to select the correct category.
     */
    function showFeedbackPrompt(predCategory) {
      const container = document.getElementById('feedbackContainer');
      if (!container) return;
      container.innerHTML = '';
      const question = document.createElement('div');
      question.style.marginTop = '8px';
      // Use translated prompt for asking about correctness
      question.textContent = translations[currentLanguage].correctRecognition;
      container.appendChild(question);
      const yesBtn = document.createElement('button');
      yesBtn.textContent = translations[currentLanguage].yes;
      yesBtn.style.marginRight = '6px';
      yesBtn.onclick = () => {
        predictionStats.correct++;
        // Reset consecutive wrong counter on a correct prediction
        consecutiveWrong = 0;
        container.innerHTML = '';
        updateStatsDisplay();
        updateErrorStatsMessage();
      };
      const noBtn = document.createElement('button');
      noBtn.textContent = translations[currentLanguage].no;
      noBtn.onclick = () => {
        predictionStats.wrong++;
        consecutiveWrong++;
        // Decrease trust slightly on incorrect prediction.
        personality.trust = Math.max(0, personality.trust - 0.1);
        // Show the detailed feedback UI including correct emotion selection, comment and suggestions.
        showFeedbackDetails();
        updateStatsDisplay();
        updateErrorStatsMessage();
        // If the assistant has been wrong multiple times in a row, express emotional feedback.
        if (consecutiveWrong >= 3) {
          const msg = translations[currentLanguage].emotionalFeedback;
          conversation.push({ user: '', reply: msg });
          if (conversation.length > 30) conversation.shift();
          updateConversation();
          speak(msg);
          consecutiveWrong = 0;
        }
      };
      container.appendChild(yesBtn);
      container.appendChild(noBtn);
    }
    /**
     * Present a dropdown to select the correct category for the last input.
     * When a selection is made, incrementally train the model on this new example.
     */
    function showCorrectCategorySelection() {
      const container = document.getElementById('feedbackContainer');
      if (!container) return;
      container.innerHTML = '';
      const label = document.createElement('div');
      label.textContent = 'Bitte w√§hle die richtige Emotion:';
      label.style.marginBottom = '4px';
      container.appendChild(label);
      const select = document.createElement('select');
      categoriesListTF.forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        select.appendChild(opt);
      });
      container.appendChild(select);
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Best√§tigen';
      confirmBtn.style.marginLeft = '6px';
      confirmBtn.onclick = async () => {
        const chosen = select.value || 'default';
        container.innerHTML = '';
        if (lastInputText && tfModel) {
          try {
            // Convert text to vector and label.
            const inputVec = vectorize(lastInputText);
            const labelVec = new Array(categoriesListTF.length).fill(0);
            const idx = categoriesListTF.indexOf(chosen);
            if (idx >= 0) labelVec[idx] = 1;
            // Add to training sets for incremental learning.
            trainingInputs.push(inputVec);
            trainingOutputs.push(labelVec);
            // Perform a small incremental fit on the single new example.
            const xs = tf.tensor2d([inputVec]);
            const ys = tf.tensor2d([labelVec]);
            // Increase epochs to improve learning from individual feedback examples.
            await tfModel.fit(xs, ys, { epochs: 15, batchSize: 1, shuffle: false });
            // Feedback replay to consolidate corrections
            if (window._egoFeedbackReplay) { await window._egoFeedbackReplay(tfModel, inputVec, labelVec, CATEGORY_MODEL_STORAGE_KEY); }
            // Save updated model to local storage.
            await tfModel.save('localstorage://' + CATEGORY_MODEL_STORAGE_KEY);
          } catch (err) {
            console.warn('Incremental training failed', err);
          }
        }
        // Update user training count and persist it.
        userTrainingCount++;
        try {
          localStorage.setItem('userTrainingCount', userTrainingCount.toString());
        } catch (e) {
          /* ignore storage errors */
        }
        // Show an acknowledgement to the user indicating the model has learned.
        const ack = document.createElement('div');
        ack.textContent = 'Danke! Ich habe gelernt.';
        ack.style.marginTop = '4px';
        ack.style.color = '#8f8';
        container.appendChild(ack);
        // Refresh statistics display so the new training count is visible.
        updateStatsDisplay();
      };
      container.appendChild(confirmBtn);
    }

    /**
     * Update the error statistics message based on accumulated misclassification counts.
     * Displays a sentence informing the user which emotions are often confused.
     * Uses the translations.errorConfuse template with placeholders {correct} and {predicted}.
     */
    function updateErrorStatsMessage() {
      const msgEl = document.getElementById('errorStatsMessage');
      if (!msgEl) return;
      // Determine the misclassification pair with the highest count
      let maxCount = 0;
      let topPair = null;
      for (const pairKey in misclassificationCounts) {
        const cnt = misclassificationCounts[pairKey];
        if (cnt > maxCount) {
          maxCount = cnt;
          topPair = pairKey;
        }
      }
      if (!topPair || maxCount < 1) {
        msgEl.textContent = '';
        return;
      }
      // Parse the pair key into predicted and correct categories
      const parts = topPair.split('->');
      if (parts.length !== 2) {
        msgEl.textContent = '';
        return;
      }
      const predicted = parts[0];
      const correct = parts[1];
      // Choose display names based on current language
      const predName = categoryDisplayNames[currentLanguage][predicted] || predicted;
      const corrName = categoryDisplayNames[currentLanguage][correct] || correct;
      // Fill the template
      const template = translations[currentLanguage].errorConfuse;
      // If there is only a single recorded misclassification, avoid displaying the
      // message permanently.  Only show confusion messages once the same
      // confusion has occurred at least twice.  This prevents the hint
      // "Ich verwechsle oft ..." from appearing after a single correction.
      if (maxCount < 2) {
        msgEl.textContent = '';
        return;
      }
      const filled = template.replace('{predicted}', predName).replace('{correct}', corrName);
      // Clear any existing hide timer to avoid multiple timers stacking
      if (msgEl._hideTimeout) {
        clearTimeout(msgEl._hideTimeout);
      }
      msgEl.textContent = filled;
      // Automatically remove the message after 10 seconds so it does not linger
      msgEl._hideTimeout = setTimeout(() => {
        msgEl.textContent = '';
        msgEl._hideTimeout = null;
      }, 10000);
    }

    /**
     * Display a detailed feedback form allowing the user to specify what went wrong,
     * choose the correct emotion, and optionally select an alternative reply.
     * Records the feedback, trains the model on the corrected data and its synonyms,
     * updates error statistics and training history, and thanks the user.
     */
    function showFeedbackDetails() {
      const container = document.getElementById('feedbackContainer');
      if (!container) return;
      container.innerHTML = '';
      // Comment prompt
      const commentLabel = document.createElement('div');
      commentLabel.textContent = translations[currentLanguage].commentPrompt;
      commentLabel.style.marginBottom = '4px';
      container.appendChild(commentLabel);
      const commentInput = document.createElement('textarea');
      commentInput.style.width = '100%';
      commentInput.style.height = '50px';
      commentInput.style.resize = 'vertical';
      container.appendChild(commentInput);
      // Correct category selector
      const catLabel = document.createElement('div');
      catLabel.textContent = translations[currentLanguage].correctEmotionPrompt;
      catLabel.style.marginTop = '6px';
      catLabel.style.marginBottom = '4px';
      container.appendChild(catLabel);
      const select = document.createElement('select');
      for (const cat of categoriesListTF) {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = categoryDisplayNames[currentLanguage][cat] || cat;
        select.appendChild(opt);
      }
      container.appendChild(select);
      // Suggestions intro
      const suggIntro = document.createElement('div');
      suggIntro.textContent = translations[currentLanguage].suggestionsIntro;
      suggIntro.style.marginTop = '6px';
      suggIntro.style.marginBottom = '4px';
      container.appendChild(suggIntro);
      // Generate two alternative responses from other categories
      const suggestionsContainer = document.createElement('div');
      suggestionsContainer.style.display = 'flex';
      suggestionsContainer.style.flexDirection = 'column';
      suggestionsContainer.style.gap = '6px';
      // Determine candidate categories excluding the last predicted category
      const candidates = categoriesListTF.filter(c => c !== lastPredictedCategory && c !== 'default');
      for (let i = 0; i < 2; i++) {
        if (candidates.length === 0) break;
        const idx = Math.floor(Math.random() * candidates.length);
        const catKey = candidates.splice(idx, 1)[0];
        let respArr;
        if (currentLanguage === 'en' && categoriesEnglish[catKey]) {
          respArr = categoriesEnglish[catKey].responses;
        } else {
          respArr = originalResponses[catKey] || categories[catKey].responses;
        }
        const resp = respArr[Math.floor(Math.random() * respArr.length)];
        const altDiv = document.createElement('div');
        altDiv.style.display = 'flex';
        altDiv.style.flexDirection = 'column';
        altDiv.style.background = '#333';
        altDiv.style.padding = '6px';
        altDiv.style.border = '1px solid #555';
        altDiv.style.borderRadius = '4px';
        const respText = document.createElement('div');
        respText.textContent = resp;
        altDiv.appendChild(respText);
        const chooseBtn = document.createElement('button');
        chooseBtn.textContent = translations[currentLanguage].alternativeBtn;
        chooseBtn.style.marginTop = '4px';
        chooseBtn.onclick = () => {
          if (conversation.length > 0) {
            conversation[conversation.length - 1].reply = resp;
            updateConversation();
            speak(resp);
            try {
              localStorage.setItem('egoConversation', JSON.stringify(conversation));
            } catch (e) {}
          }
        };
        altDiv.appendChild(chooseBtn);
        suggestionsContainer.appendChild(altDiv);
      }
      container.appendChild(suggestionsContainer);
      // Confirm button
      const confirm = document.createElement('button');
      confirm.textContent = translations[currentLanguage].confirmFeedback;
      confirm.style.marginTop = '8px';
      confirm.onclick = async () => {
        const chosen = select.value || 'default';
        const comment = commentInput.value.trim();
        if (comment) {
          feedbackComments.push(comment);
        }
        // Update misclassification counts using predicted->chosen pair
        if (lastPredictedCategory) {
          const key = lastPredictedCategory + '->' + chosen;
          misclassificationCounts[key] = (misclassificationCounts[key] || 0) + 1;
        }
        // Save feedback
        savePersistentData();
        // Train on the original input and synonyms
        if (lastInputText && typeof tfModel !== 'undefined' && tfModel) {
          await incrementalTrain(lastInputText, chosen);
          const lower = lastInputText.toLowerCase();
          for (const phrase in synonymsMapping) {
            if (lower.includes(phrase)) {
              const synonyms = synonymsMapping[phrase];
              for (const syn of synonyms) {
                await incrementalTrain(syn, chosen);
              }
            }
          }
        }
        // Record training history for this text
        if (lastInputText) {
          const keyText = lastInputText.toLowerCase().trim();
          if (!trainingHistory[keyText]) {
            trainingHistory[keyText] = {};
          }
          trainingHistory[keyText].original = lastPredictedCategory;
          trainingHistory[keyText].corrected = chosen;
          trainingHistory[keyText].improved = false;
        }
        savePersistentData();
        // Increment training counter and update display
        userTrainingCount++;
        try {
          localStorage.setItem('userTrainingCount', userTrainingCount.toString());
        } catch (e) {}
        // Acknowledge training
        const ack = document.createElement('div');
        ack.textContent = translations[currentLanguage].trainingAcknowledgement;
        ack.style.marginTop = '4px';
        ack.style.color = '#8f8';
        container.innerHTML = '';
        container.appendChild(ack);
        updateStatsDisplay();
        updateErrorStatsMessage();
      };
      container.appendChild(confirm);
    }

    /**
     * Train the model incrementally on a single text-category pair.  Converts the text
     * into the appropriate vector representation, appends to the training set and
     * performs a brief fit.  The model is saved to localStorage for persistence.
     * @param {string} text The input text to train on.
     * @param {string} category The correct category for the text.
     */
    async function incrementalTrain(text, category) {
      try {
        if (!text || !tfModel) return;
        const inputVec = vectorize(text);
        const labelVec = new Array(categoriesListTF.length).fill(0);
        const idx = categoriesListTF.indexOf(category);
        if (idx >= 0) labelVec[idx] = 1;
        trainingInputs.push(inputVec);
        trainingOutputs.push(labelVec);
        const xs = tf.tensor2d([inputVec]);
        const ys = tf.tensor2d([labelVec]);
        // Train for more epochs to better incorporate feedback.  Increasing
        // epochs from 5 to 15 ensures the model internalises the new example
        // more strongly without significantly impacting performance.
        await tfModel.fit(xs, ys, { epochs: 15, batchSize: 1, shuffle: false });
            // Feedback replay to consolidate corrections
            if (window._egoFeedbackReplay) { await window._egoFeedbackReplay(tfModel, inputVec, labelVec, CATEGORY_MODEL_STORAGE_KEY); }
        await tfModel.save('localstorage://' + CATEGORY_MODEL_STORAGE_KEY);
      } catch (err) {
        console.warn('Incremental training failed', err);
      }
    }

    // === Added machine learning support ===
    // We prepare a small training corpus using the category keywords and
    // additional sentiment word lists.  Each sample is converted into a
    // bag-of-words vector and labelled with its category.  At load
    // time a simple neural network is trained to recognise these
    // categories.  When a message is received, the model's prediction
    // can override the rule-based category if the confidence is high.
    // TensorFlow model used for category classification.  This will be
    // lazily initialised either by loading from browser storage or,
    // if no saved model is present, by training a new one.  Using a
    // persistent key allows the model to survive across page reloads.
    let tfModel = null;
    const CATEGORY_MODEL_STORAGE_KEY = 'category-model';
    let vocab = [];
    let vocabIndex = {};
    const categoriesListTF = ['dislike','greeting','farewell','anger','sadness','joy','fear','surprise','trust','default'];
    // Construct training samples by combining category keywords with
    // dedicated word lists to enrich the model's understanding.
    const categoryTrainingWords = {
      dislike: [].concat(categories.dislike.keywords),
      greeting: [].concat(categories.greeting.keywords),
      farewell: [].concat(categories.farewell.keywords),
      anger: [].concat(categories.anger.keywords, angerWords),
      sadness: [].concat(categories.sadness.keywords, sadnessWords),
      joy: [].concat(categories.joy.keywords, joyWords),
      fear: [].concat(categories.fear.keywords, fearWords),
      surprise: [].concat(categories.surprise.keywords),
      trust: [].concat(categories.trust.keywords),
      default: ['neutral','erz√§hl','wie geht','interessant','denke','bewusstsein']
    };
    // Build vocabulary from all category training words.  Unknown words
    // encountered at prediction time are simply ignored.
    (function buildVocab() {
      const set = new Set();
      for (const cat in categoryTrainingWords) {
        categoryTrainingWords[cat].forEach(phrase => {
          phrase.toLowerCase().split(/\s+/).forEach(tok => {
            if (tok) set.add(tok);
          });
        });
      }
      vocab = Array.from(set);
      vocabIndex = {};
      vocab.forEach((word, idx) => { vocabIndex[word] = idx; });
    })();
    // Vectorise a text sample into a binary bag-of-words vector.
    function vectorize(text) {
      const vec = new Array(vocab.length).fill(0);
      const tokens = text.toLowerCase().split(/\s+/).filter(Boolean);
      tokens.forEach(t => {
        const idx = vocabIndex[t];
        if (idx !== undefined) vec[idx] = 1;
      });
      return vec;
    }
    // Prepare the training dataset once.
    const trainingInputs = [];
    const trainingOutputs = [];
    (function buildTrainingSet() {
      categoriesListTF.forEach(cat => {
        const phrases = categoryTrainingWords[cat] || [];
        phrases.forEach(p => {
          trainingInputs.push(vectorize(p));
          const label = new Array(categoriesListTF.length).fill(0);
          label[categoriesListTF.indexOf(cat)] = 1;
          trainingOutputs.push(label);
        });
      });
    })();
    // Create and train the model asynchronously.
    async function createAndTrainModel() {
      // Attempt to load a previously saved model from browser storage.
      // If present, this avoids re‚Äëtraining on every page load.  Any
      // errors during load (e.g. no model stored) fall through to
      // training a fresh model.
      try {
        tfModel = await tf.loadLayersModel('localstorage://' + CATEGORY_MODEL_STORAGE_KEY);
        console.log('Loaded existing category model from local storage');
        return;
      } catch (loadErr) {
        console.log('No stored category model found, training a new one');
      }
      if (trainingInputs.length === 0) return;
      const xs = tf.tensor2d(trainingInputs);
      const ys = tf.tensor2d(trainingOutputs);
      const model = tf.sequential();
      // Use a slightly larger hidden layer to improve performance while
      // keeping the network compact.  Adjusting units here helps the
      // model capture more nuance without excessive size.
      model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [vocab.length] }));
      model.add(tf.layers.dense({ units: categoriesListTF.length, activation: 'softmax' }));
      model.compile({ optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy'] });
      await model.fit(xs, ys, { epochs: 60, batchSize: 8, shuffle: true });
      tfModel = model;
      // Persist the trained model so that subsequent visits can reuse it.
      try {
        await model.save('localstorage://' + CATEGORY_MODEL_STORAGE_KEY);
        console.log('Category model saved to local storage');
      } catch (saveErr) {
        console.warn('Failed to save category model', saveErr);
      }
    }
    // Kick off training immediately.  If training fails for any
    // reason, the model will remain null and rule-based detection
    // continues to operate.
    createAndTrainModel().catch(err => { console.error('Model training failed', err); });
    // Predict category with the trained model.  Returns a promise
    // resolving to { category, confidence }.
    async function modelPredictCategory(text) {
      if (!tfModel) return { category: 'default', confidence: 0 };
      const vec = vectorize(text);
      const inputTensor = tf.tensor2d([vec]);
      const prediction = tfModel.predict(inputTensor);
      const data = await prediction.data();
      let bestIndex = 0;
      let bestVal = data[0];
      for (let i = 1; i < data.length; i++) {
        if (data[i] > bestVal) {
          bestVal = data[i];
          bestIndex = i;
        }
      }
      return { category: categoriesListTF[bestIndex] || 'default', confidence: bestVal };
    }

    

    // === Phrase priorities and SVO detection from compromise ===
    const phrasePriorities = [
      { rex: /\bdu\s+bist\s+mein\s+freund\b/i, delta: { vertrauen: +50, freude: +20, wut: -10, angst: -10, traurigkeit: -10 } },
      { rex: /\bich\s+hasse\s+dich\b/i, delta: { wut: +40, vertrauen: -40, freude: -30, traurigkeit: +20, angst: +10 } }
    ];
    function applyPhrasePriorities(text, e) {
      phrasePriorities.forEach(p => {
        if (p.rex.test(text)) {
          Object.keys(p.delta).forEach(k => { e[k] = clamp(e[k] + p.delta[k]); });
        }
      });
    }
    function detectSVO(text) {
      try {
        if (typeof nlp !== 'function') return null;
        const doc = nlp(text);
        const subj = doc.nouns().first().text() || '';
        const verb = doc.verbs().first().text() || '';
        let obj = '';
        try {
          const afterVerb = doc.splitAfter(doc.verbs().first()).last();
          obj = afterVerb.nouns().last().text() || '';
        } catch (_) {}
        return { subject: subj, verb: verb, object: obj };
      } catch (err) { return null; }
    }

    /**
     * Main interaction handler.  This function is asynchronous to
     * accommodate the machine learning prediction.  It preserves all
     * previous behaviours ‚Äì memory, conversation display, emotion
     * updates, speech synthesis ‚Äì while allowing the TensorFlow.js
     * model to override the rule-based category when sufficiently
     * confident.  Thresholds can be tuned to balance between rule-
     * based and learned behaviours.
     */
    async function interact() {
      const text = input.value;
      // Remember the last input for potential feedback-based training.
      lastInputText = text;
      if (!text.trim()) return;
      input.value = '';
      // Store this input in short-term memory.  Keep only the
      // most recent five inputs to maintain a manageable context.
      memory.push(text);
      if (memory.length > 5) memory.shift();
      // === Extract and store key nouns ===
      // Use compromise.js to identify nouns in the user‚Äôs input.  These
      // nouns capture names, places or other salient entities.  We
      // normalise them to lower case and filter out empty values.
      try {
        let nouns = [];
        // Attempt to use compromise.js if available.  The global `nlp`
        // function is provided by the compromise library loaded in
        // <head>.  If it is undefined or does not support noun
        // extraction, this call will throw and fall back.
        try {
          const doc = (typeof nlp === 'function') ? nlp(text) : null;
          if (doc && doc.nouns) {
            nouns = doc.nouns().out('array');
          }
        } catch (ignore) {}
        // Fallback: if no nouns were found, perform a very simple
        // heuristic by selecting words that start with a capital letter
        // (common for names and places in German) or are longer than 4
        // characters.  Split on whitespace and filter out punctuation.
        if (!Array.isArray(nouns) || nouns.length === 0) {
          const words = text.split(/\s+/);
          nouns = words.filter(w => {
            // Remove leading and trailing punctuation/symbols.  Use a
            // conservative character set to avoid unsupported regex features.
            const clean = w.replace(/^[^a-zA-Z√Ñ√ñ√ú√§√∂√º√ü]+|[^a-zA-Z√Ñ√ñ√ú√§√∂√º√ü]+$/g, '');
            if (!clean) return false;
            // Define a small set of stopwords to ignore common function words.
            const stopwords = ['ich','du','er','sie','wir','ihr','the','and','und','mit','das','die','der','in','an','auf'];
            if (stopwords.includes(clean.toLowerCase())) return false;
            // Consider words starting with an uppercase letter or words
            // longer than five characters as potential nouns.
            const firstChar = clean.charAt(0);
            const isUpper = firstChar === firstChar.toUpperCase();
            return isUpper || clean.length > 5;
          });
        }
        if (Array.isArray(nouns)) {
          nouns.map(n => n && n.trim().toLowerCase()).forEach(noun => {
            if (!noun) return;
            if (!memory.topics.includes(noun)) {
              memory.topics.push(noun);
              if (memory.topics.length > 10) memory.topics.shift();
            }
          });
        }
      } catch (err) {
        // If noun extraction fails, simply ignore this step.
      }
      // Predict the basic emotion distribution using our tiny neural model.
      try {
        const emotionResults = await predictEmotionDistribution(text);
        // Store the last emotion distribution globally for enhanced replies.
        lastEmotionResults = emotionResults;
        // If the host page defines handlers for updating the face or speaking
        // based on emotion, call them here.  We wrap calls in try/catch
        // blocks to avoid disrupting the interaction flow if these
        // functions are undefined or throw errors.
        if (typeof updateFaceBasedOnEmotion === 'function') {
          try { updateFaceBasedOnEmotion(emotionResults); } catch (err) { console.warn('updateFaceBasedOnEmotion error', err); }
        }
        // Allow external handlers to receive the raw emotion probabilities.  If
        // a global handleEmotionOutput function is defined, pass the
        // prediction object directly to it.  This enables custom
        // responses or side effects outside of this component.
        if (typeof handleEmotionOutput === 'function') {
          try { handleEmotionOutput(emotionResults); } catch (err) { console.warn('handleEmotionOutput error', err); }
        }
        if (typeof speakResponse === 'function') {
          try { speakResponse(emotionResults); } catch (err) { console.warn('speakResponse error', err); }
        }
      } catch (err) {
        console.warn('Emotion prediction failed:', err);
      }

      // Start with rule-based detection.
      let category = detectCategory(text);
      // If a trained model exists, query it for a prediction.
      try {
        const result = await modelPredictCategory(text);
        // If the model is confident and the category exists, override.
        if (result && result.confidence > 0.65 && categories[result.category]) {
          category = result.category;
        }
      } catch (err) {
        console.warn('Model prediction failed:', err);
      }
      // Record the predicted category for feedback and update personality.
      lastPredictedCategory = category;
      updatePersonality(category);
      // Apply category updates.
      const catObj = categories[category] || categories.default;
      catObj.update(emotion);
      // Apply phrase-level priorities.
      applyPhrasePriorities(text, emotion);

      // ===== Evil mode logic =====
      // Update an anger streak counter whenever the predicted category is
      // outright anger.  If another category follows, decrement the
      // counter rather than resetting it entirely.  This approach
      // tolerates occasional misclassifications and still allows the
      // streak to build when the user expresses anger repeatedly.  Once
      // the streak reaches two, evil mode is triggered; the streak must
      // return to zero before evil mode is cleared.  Using the
      // predicted category rather than the dominant emotion ensures
      // explicit expressions of anger are what drive the state change.
     const angerDominant = emotion.wut > emotion.freude + 5 && emotion.wut > emotion.vertrauen + 5;
      {
        /*
         * Determine whether anger is dominating in the current emotion state.
         * We consider anger dominant if the wut (anger) level exceeds both
         * freude (joy) and vertrauen (trust) by at least 5 points.  In
         * practice this catches messages that clearly convey anger even
         * when the classifier does not assign the ‚Äúanger‚Äù category.  If
         * anger is dominant or the model explicitly predicts the anger
         * category, increment the streak.  Friendly categories (joy or
         * trust) reduce the streak faster.  Other categories (sadness,
         * fear, etc.) decrement slightly.  Once the streak reaches two,
         * the evil mode is triggered; it remains active until the streak
         * drops back to zero.
         */
        
        if (category === 'anger' || angerDominant) {
          angerStreak = Math.min(angerStreak + 1, 5);
        } else if (category === 'joy' || category === 'trust') {
          angerStreak = Math.max(0, angerStreak - 2);
        } else {
          angerStreak = Math.max(0, angerStreak - 1);
        }
        if (angerStreak >= 2 && !evilMode) {
          evilMode = true;
          entity.classList.add('evil');
        } else if (angerStreak === 0 && evilMode) {
          evilMode = false;
          entity.classList.remove('evil');
        }
      }
     triggerEmotionBubble(category, angerDominant);
      // SVO detection for potential future logic (logged only).
      const svo = detectSVO(text);
      if (svo) { console.log('SVO detected', svo); }
      // Render the entity now that emotions have changed.
      renderEntity();
      // If this text has previously been corrected and the model now predicts the correct category,
      // acknowledge the learning progress.
      const normText = text.toLowerCase().trim();
      if (trainingHistory[normText] && trainingHistory[normText].corrected) {
        const correctedCat = trainingHistory[normText].corrected;
        if (category === correctedCat && !trainingHistory[normText].improved) {
          trainingHistory[normText].improved = true;
          savePersistentData();
          const progressMsg = translations[currentLanguage].learningProgress;
          conversation.push({ user: '', reply: progressMsg });
          if (conversation.length > 30) conversation.shift();
          updateConversation();
          speak(progressMsg);
        }
      }
      // Choose a random reply and adapt it based on personality.
      const replies = catObj.responses;
      const baseReply = replies[Math.floor(Math.random() * replies.length)];
      const reply = adaptReplyBasedOnPersonality(baseReply);
      // Generate a smarter reply by incorporating emotion and SVO context.
      const finalReply = await generateSmartReply(text, reply, lastEmotionResults);
      conversation.push({ user: text, reply: finalReply });
      if (conversation.length > 30) conversation.shift();
      updateConversation();
      // Update the memory display with both recent inputs and any
      // extracted topics.  Topics are shown in brackets after the
      // inputs, separated by commas.
      {
        let memStr = memory.join(' | ');
        if (Array.isArray(memory.topics) && memory.topics.length > 0) {
          memStr += ' [' + memory.topics.join(', ') + ']';
        }
        memoryBox.textContent = translations[currentLanguage].memoryPrefix + ' ' + memStr;
      }
      try {
        localStorage.setItem('egoMemory', JSON.stringify(memory));
        // Persist topics separately since custom properties on arrays are
        // not included when stringifying.  If memory.topics does not
        // exist, default to an empty array.  This call ensures the
        // extracted nouns survive page reloads.
        const topicsToStore = Array.isArray(memory.topics) ? memory.topics : [];
        localStorage.setItem('egoMemoryTopics', JSON.stringify(topicsToStore));
        localStorage.setItem('egoConversation', JSON.stringify(conversation));
      } catch (e) {}
      // Speak the final reply (if voice is enabled).
      speak(finalReply);
      // Show a feedback prompt so the user can evaluate the classification.
      showFeedbackPrompt(category);
      // Update statistics display initially (no effect if zero interactions yet).
      updateStatsDisplay();
    }

    // === Additional settings functions and event listeners ===
    /**
     * Clear only the visible conversation history while preserving memory
     * and learned model data.  This resets the conversation array and
     * updates browser storage accordingly.
     */
    function clearConversation() {
      conversation = [];
      responseBox.innerHTML = '';
      try {
        localStorage.setItem('egoConversation', JSON.stringify(conversation));
      } catch (e) {
        /* ignore storage errors */
      }
      // Also reset any accumulated misclassification statistics so that
      // lingering confusion messages are cleared.  The confusion counts
      // are persisted separately and need to be reset explicitly.
      misclassificationCounts = {};
      try {
        localStorage.setItem('misclassificationCounts', JSON.stringify(misclassificationCounts));
      } catch (e) {
        /* ignore storage errors */
      }
      // Update the error statistics display to reflect the cleared state.
      updateErrorStatsMessage();
    }
    /**
     * Toggle voice input and output on/off.  When disabled, the microphone
     * button is hidden and the speak() function will not trigger speech.
     * The setting is persisted to localStorage.
     */
    function toggleVoice() {
      // Toggle whether EgoMorph will speak its replies via speech synthesis.
      voiceEnabled = !voiceEnabled;
      // Persist the flag.  Do not hide the microphone here; the microphone
      // remains available for voice input regardless of this setting.
      try {
        localStorage.setItem('voiceEnabled', voiceEnabled ? 'true' : 'false');
      } catch (e) {
        /* ignore storage errors */
      }
    }
    // Register event listeners after page load for settings UI controls.
    window.addEventListener('load', () => {
      const settingsToggle = document.getElementById('settingsToggle');
      const settingsPanel = document.getElementById('settingsPanel');
      const clearBtn = document.getElementById('clearConvBtn');
      const toggleBtn = document.getElementById('toggleVoiceBtn');
      const downloadBtn = document.getElementById('downloadModelBtn');
      const setDefBtn = document.getElementById('setDefaultEmotionBtn');
      const selectEm = document.getElementById('defaultEmotionSelect');
      // Grab references for the new info and custom response UI elements.
      const infoToggle = document.getElementById('infoToggle');
      const infoPanel = document.getElementById('infoPanel');
      const customEmotionSelect = document.getElementById('customEmotionSelect');
      const customResponseInput = document.getElementById('customResponseInput');
      const addCustomResponseBtn = document.getElementById('addCustomResponseBtn');
      const customResponseList = document.getElementById('customResponseList');

      // Helper to update the list of custom responses shown in the settings.
      function updateCustomList() {
        if (!customEmotionSelect || !customResponseList) return;
        const custom = getCustomResponses();
        const selectedKey = customEmotionSelect.value;
        const list = Array.isArray(custom[selectedKey]) ? custom[selectedKey] : [];
        // Clear existing entries
        customResponseList.innerHTML = '';
        // Build a list of responses with individual remove buttons so that
        // the user can delete specific custom responses.  Each item is
        // represented by a <div> with the text and a small button.  When
        // the button is clicked, the entry is removed from both the
        // persisted custom response storage and the live categories.
        list.forEach((resp, i) => {
          const item = document.createElement('div');
          item.style.display = 'flex';
          item.style.justifyContent = 'space-between';
          item.style.alignItems = 'center';
          item.style.marginBottom = '2px';
          const span = document.createElement('span');
          span.textContent = `${i + 1}. ${resp}`;
          span.style.flexGrow = '1';
          const btn = document.createElement('button');
          btn.textContent = '‚úñ';
          btn.className = 'remove-response';
          btn.dataset.index = i;
          // Styling for the remove button to match the dark theme
          btn.style.background = '#444';
          btn.style.color = '#eee';
          btn.style.border = 'none';
          btn.style.padding = '2px 6px';
          btn.style.cursor = 'pointer';
          btn.style.marginLeft = '5px';
          // Append elements
          item.appendChild(span);
          item.appendChild(btn);
          customResponseList.appendChild(item);
        });
      }

      // Toggle display of the info panel when the info button is clicked.
      if (infoToggle && infoPanel) {
        infoToggle.addEventListener('click', () => {
          infoPanel.style.display = infoPanel.style.display === 'none' ? 'block' : 'none';
        });
      }

      // When the selected emotion changes, update the displayed list of
      // custom responses for that emotion.
      if (customEmotionSelect) {
        customEmotionSelect.addEventListener('change', updateCustomList);
      }

      // Add a new custom response when the user clicks the add button.
      if (addCustomResponseBtn && customEmotionSelect && customResponseInput) {
        addCustomResponseBtn.addEventListener('click', () => {
          const selectedKey = customEmotionSelect.value;
          const text = customResponseInput.value.trim();
          if (!selectedKey || !text) return;
          // Update stored custom responses in localStorage.
          const custom = getCustomResponses();
          if (!custom[selectedKey]) custom[selectedKey] = [];
          custom[selectedKey].push(text);
          saveCustomResponses(custom);
          // Append to the live categories structure for immediate use.
          const catKey = emotionCategoryMap[selectedKey];
          if (catKey && categories[catKey]) {
            categories[catKey].responses.push(text);
          }
          // Clear input and refresh the list display.
          customResponseInput.value = '';
          updateCustomList();
        });
      }

      // Allow users to remove individual custom responses by clicking the ‚úñ button
      // next to each entry.  Use event delegation so that the handler
      // attaches once and works for dynamically created buttons.
      if (customResponseList && customEmotionSelect) {
        customResponseList.addEventListener('click', (e) => {
          const target = e.target;
          if (target && target.classList.contains('remove-response')) {
            const idx = parseInt(target.dataset.index, 10);
            if (isNaN(idx)) return;
            const key = customEmotionSelect.value;
            const custom = getCustomResponses();
            const list = Array.isArray(custom[key]) ? custom[key] : [];
            if (idx >= 0 && idx < list.length) {
              // Remove the selected response from the custom array
              const [removed] = list.splice(idx, 1);
              custom[key] = list;
              saveCustomResponses(custom);
              // Also remove it from the live categories responses list
              const catKey = emotionCategoryMap[key];
              if (catKey && categories[catKey]) {
                // Remove all instances of the response from the responses array
                categories[catKey].responses = categories[catKey].responses.filter(r => r !== removed);
              }
              updateCustomList();
            }
          }
        });
      }

      // Populate the custom responses list once on load.
      updateCustomList();
      if (settingsToggle && settingsPanel) {
        // Ensure the panel starts hidden even if CSS was overridden by the browser.
        settingsPanel.style.display = 'none';
        settingsToggle.addEventListener('click', () => {
          const isHidden = settingsPanel.style.display === 'none' || settingsPanel.style.display === '';
          settingsPanel.style.display = isHidden ? 'flex' : 'none';
        });
      }
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          clearConversation();
        });
      }
      if (toggleBtn) {
        // Set the initial button text based on current state and language.
        toggleBtn.textContent = voiceEnabled
          ? translations[currentLanguage].voiceDeactivate
          : translations[currentLanguage].voiceActivate;
        toggleBtn.addEventListener('click', () => {
          toggleVoice();
          // Update the button text after toggling using the translation dictionary.
          toggleBtn.textContent = voiceEnabled
            ? translations[currentLanguage].voiceDeactivate
            : translations[currentLanguage].voiceActivate;
        });
      }
      if (downloadBtn) {
        downloadBtn.addEventListener('click', async () => {
          // Trigger downloads of the trained models if available.  Use
          // TensorFlow.js built‚Äëin download mechanism to prompt the user.
          if (typeof tfModel !== 'undefined' && tfModel) {
            try {
              await tfModel.save('downloads://egoMorphCategoryModel');
            } catch (err) {
              console.warn('Category model download failed', err);
            }
          }
          if (typeof emotionModel !== 'undefined' && emotionModel) {
            try {
              await emotionModel.save('downloads://egoMorphEmotionModel');
            } catch (err) {
              console.warn('Emotion model download failed', err);
            }
          }
        });
      }
      if (setDefBtn && selectEm) {
        setDefBtn.addEventListener('click', () => {
          const sel = selectEm.value;
          if (sel && emotion[sel] !== undefined) {
            for (const key in emotion) {
              emotion[key] = (key === sel ? 60 : 10);
            }
            try {
              localStorage.setItem('defaultEmotion', sel);
            } catch (e) {
              /* ignore */
            }
            renderEntity();
          }
        });
      }

      // Set up language selector and apply current language settings on load.
      const langSelectElem = document.getElementById('languageSelect');
      if (langSelectElem) {
        langSelectElem.value = currentLanguage;
        langSelectElem.addEventListener('change', (e) => {
          changeLanguage(e.target.value);
        });
      }
      // Refresh the UI to reflect the stored language preference.
      updateUIForLanguage();
      // Update error statistics on initial load.
      updateErrorStatsMessage();
    });

    // Initial render to set up eyes/mouth.
    renderEntity();

    // === Gaze tracking with mouse movement ===
    // Listen for pointer movements and update pupil positions relative to
    // each eye.  The offset is calculated based on the pointer‚Äôs
    // displacement from the centre of each eye and clamped so the pupils
    // remain inside the whites.  Multiplying by 50% converts the
    // normalised offset into percentage translation values.  This
    // handler runs continuously and leverages the short CSS transition
    // defined on `.pupil` for smooth movement.
    document.addEventListener('mousemove', (ev) => {
      // Only proceed if pupils and eyes are available.
      if (!leftEye || !rightEye || !leftPupil || !rightPupil) return;
      // Helper function to update a single eye‚Äôs pupil position.  This
      // implementation adjusts the CSS left/top properties rather than
      // using transform.  Starting from a base of 30%, the pupil can
      // move up to ¬±10% of the eye‚Äôs width/height along each axis.
      const updatePupilPos = (eyeEl, pupilEl) => {
        const rect = eyeEl.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        // Normalise displacement relative to eye size
        let dx = (ev.clientX - cx) / rect.width;
        let dy = (ev.clientY - cy) / rect.height;
        // Clamp to avoid leaving the whites
        const maxOffset = 0.5;
        dx = Math.max(-maxOffset, Math.min(maxOffset, dx));
        dy = Math.max(-maxOffset, Math.min(maxOffset, dy));
        // Compute new top/left positions as percentages.  Base position
        // centres the pupil at 30% top/left; we add up to ¬±10% shift.
        // Base position corresponds to the initial left/top defined in the CSS (25%).
        const basePos = 25;
        // Allow the pupil to move further away from the centre by
        // increasing the range.  A range of 20 permits ¬±10% offsets
        // relative to the base position, providing a more noticeable
        // movement across the eye.
        const range = 20;
        const newLeft = basePos + dx * range;
        const newTop = basePos + dy * range;
        pupilEl.style.left = `${newLeft}%`;
        pupilEl.style.top = `${newTop}%`;
      };
      updatePupilPos(leftEye, leftPupil);
      updatePupilPos(rightEye, rightPupil);
    });

    // Anleitung zum Hinzuf√ºgen neuer Emotionen:
    //
    // Um zus√§tzliche Emotionen wie "angst" oder "ueberraschung" zu integrieren,
    // gehe so vor:
    // 1. F√ºge der Liste emotionClasses die neue Emotion hinzu.
    // 2. Erg√§nze emotionTrainingPhrases um ein Array mit vielen Beispiels√§tzen f√ºr
    //    diese Emotion.  Mindestens 20‚Äì30 S√§tze mit varianten Formulierungen sind
    //    empfehlenswert.
    // 3. Beim n√§chsten Laden der Seite werden Vokabular und Modelle automatisch
    //    aktualisiert und trainiert.  Die Speicherung erfolgt im Browser,
    //    sodass neu gelernte Modelle wiederverwendet werden.
  // ====== PWA and Welcome Modal Setup ======
  document.addEventListener('DOMContentLoaded', () => {
    // Show welcome message once
    const modal = document.getElementById('welcomeModal');
    const closeBtn = document.getElementById('closeModalBtn');
    if (modal) {
      if (localStorage.getItem('welcomeShown')) {
        modal.style.display = 'none';
      } else {
        modal.style.display = 'flex';
      }
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          modal.style.display = 'none';
          localStorage.setItem('welcomeShown', 'true');
        });
      }
    }
    // Prepare installation button for PWA
    const installBtn = document.createElement('button');
    installBtn.id = 'installBtn';
    installBtn.style.display = 'none';
    if (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].installBtn) {
      installBtn.textContent = translations[currentLanguage].installBtn;
    } else {
      installBtn.textContent = 'Installieren';
    }
    const inputSection = document.getElementById('inputSection');
    if (inputSection) {
      inputSection.insertBefore(installBtn, inputSection.firstChild);
    }
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'block';
    });
    installBtn.addEventListener('click', async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        await deferredPrompt.userChoice;
        deferredPrompt = null;
        installBtn.style.display = 'none';
      }
    });
    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(err => {
        console.log('Service worker registration failed:', err);
      });
    }
  });
</script>
  <!-- Load the appearance settings logic.  This separate script
       listens for changes on the shape and colour selectors in the
       settings panel and applies them to the entity.  Keeping this
       functionality in its own file avoids cluttering the main
       index.html with implementation details. -->
  <!-- Load the appearance settings script with the defer attribute so
       that it executes after the document has been parsed.  This
       ensures the relevant DOM elements are available without
       needing to wait for DOMContentLoaded manually. -->
  <script src="ego_settings.js" defer></script>

  <script>
    // === Lightweight NLP Boost (non-breaking) ===
    // Keeps all existing functions. We add helpers and call them from generateSmartReply.
    const __stopwords = new Set(['der','die','das','und','oder','aber','denn','ein','eine','einer','einem','einen','ist','sind','war','waren','zu','mit','auf','an','im','in','am','vom','vom','f√ºr','von','wie','ich','du','er','sie','es','wir','ihr','sie','mal','halt','eben','auch','noch','schon','nur','nicht','kein','keine']);
    const __synonyms = {
      traurig:['depressiv','down','betr√ºbt','bedr√ºckt','niedergeschlagen','traurig'],
      w√ºtend:['sauer','aggressiv','genervt','wut','ausrasten','ausflippen','zornig','w√ºtend'],
      froh:['gl√ºcklich','happy','zufrieden','erleichtert','freu mich','yay','nice'],
      angst:['√§ngstlich','angst','unsicher','panik','sorge','besorgt']
    };
    const __intents = [
      {name:'frage_faehigkeit', patterns:['was kannst du','wozu bist du in der lage','was machst du','was kann ego','deine funktionen']},
      {name:'speichern', patterns:['speicher','save','merken','erinner','notier','speichere das']},
      {name:'hilfe', patterns:['hilfe','help','wie geht','anleitung','schritt f√ºr schritt']},
      {name:'feedback_neg', patterns:['du liegst falsch','stimmt nicht','nein falsch','das ist falsch','komplett daneben']},
      {name:'stimmung', patterns:['mir geht es','ich f√ºhle','bin','stimmung','laune']},
    ];
    function __normalize(t){
      return (t||'').toLowerCase()
        .replace(/[\u0300-\u036f]/g,'') // strip diacritics
        .replace(/[^\p{L}\p{N}\s]/gu,' ')
        .replace(/\s+/g,' ')
        .trim();
    }
    function __tokens(t){
      const norm = __normalize(t);
      return norm.split(' ').filter(w=>w && !__stopwords.has(w));
    }
    function __lev(a,b){
      // Damerau‚ÄìLevenshtein distance (small, fast)
      const al=a.length, bl=b.length;
      const dp=Array.from({length:al+1},()=>Array(bl+1).fill(0));
      for(let i=0;i<=al;i++) dp[i][0]=i;
      for(let j=0;j<=bl;j++) dp[0][j]=j;
      for(let i=1;i<=al;i++){
        for(let j=1;j<=bl;j++){
          const cost=a[i-1]===b[j-1]?0:1;
          dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
          if(i>1 && j>1 && a[i-1]===b[j-2] && a[i-2]===b[j-1]){
            dp[i][j]=Math.min(dp[i][j], dp[i-2][j-2]+1);
          }
        }
      }
      return dp[al][bl];
    }
    function __fuzzyIncludes(text, pattern){
      const t = __normalize(text);
      const p = __normalize(pattern);
      if (t.includes(p)) return true;
      // token-level fuzzy
      const tt = __tokens(t);
      const pt = __tokens(p);
      let hits=0;
      pt.forEach(pw=>{
        const best = Math.min(...tt.map(tw => __lev(pw, tw)));
        if (best <= Math.max(1, Math.floor(pw.length*0.34))) hits++;
      });
      return hits >= Math.max(1, Math.ceil(pt.length*0.6));
    }
    function __detectIntent(text){
      for(const intent of __intents){
        for(const pat of intent.patterns){
          if(__fuzzyIncludes(text, pat)) return intent.name;
        }
      }
      return null;
    }
    function __expandSynonyms(text){
      // augment text by appending synonym tags that help simple models
      const lower = text.toLowerCase();
      let tags = [];
      for(const [k,arr] of Object.entries(__synonyms)){
        for(const w of arr){
          if(lower.includes(w)){
            tags.push('#'+k);
            break;
          }
        }
      }
      return text + (tags.length?(' '+tags.join(' ')):'');
    }

    // Patch hook: wrap the existing send/compose pipeline if present
    if (typeof window.generateSmartReply === 'function'){
        const __origSmart = window.generateSmartReply;
        // Wrap the original smart reply generator in an async function so that
        // Promises returned by __origSmart are properly awaited.  Without
        // awaiting, concatenating a Promise into a string results in
        // "[object Promise]" appearing in the output.
        window.generateSmartReply = async function(text, reply, emotionResults){
          // Enrich input with synonyms and infer intent
          const enriched = __expandSynonyms(text);
          const intent = __detectIntent(enriched);
          // Await the original function in case it is asynchronous.  If it
          // returns synchronously, await will simply resolve to its value.
          let better = await __origSmart(enriched, reply, emotionResults);
          // Light intent-based refinement
          if(intent==='hilfe'){
            better = better + ' Wenn du magst, f√ºhre ich dich Schritt f√ºr Schritt durch.';
          } else if(intent==='speichern'){
            better = 'Verstanden. Ich habe das markiert. M√∂chtest du es dauerhaft speichern? ' + better;
          } else if(intent==='feedback_neg'){
            better = 'Danke f√ºr das klare Feedback. Ich passe meine Interpretation an. ' + better;
          }
          return better;
        }
    }
    // Calibrate emotion prediction confidence to avoid overconfident wrong answers
    if (typeof window.predictEmotionDistribution === 'function'){
      const _oldPred = window.predictEmotionDistribution;
      window.predictEmotionDistribution = async function(text){
        const out = await _oldPred(__expandSynonyms(text));
        // Smooth distribution a bit
        const keys = Object.keys(out);
        const eps = 0.02;
        let sum = 0;
        keys.forEach(k=>{ out[k] = Math.max(eps, out[k]); sum += out[k]; });
        keys.forEach(k=>{ out[k] /= sum; });
        return out;
      }
    }
  </script>


<script>
(() => {
  // Personalize replies by addressing the saved user name, if available.
  const _origGen = window.generateSmartReply;
  if (typeof _origGen === 'function') {
    window.generateSmartReply = async function(text, reply, emotionResults) {
      const base = await _origGen(text, reply, emotionResults);
      let name = '';
      try { name = localStorage.getItem('egoUserName') || ''; } catch (_) {}
      if (name && typeof name === 'string' && name.trim()) {
        return name.trim() + ', ' + base;
      }
      return base;
    };
  }
  // Settings UI handlers for name save/load.
  function applySavedNameToUI() {
    let n = '';
    try {
      n = localStorage.getItem('egoUserName') || '';
    } catch (_) {
      n = '';
    }
    const input = document.getElementById('userNameInput');
    if (input && n && !input.value) {
      input.value = n;
    }
    if (typeof window.renderSavedUserNameLabel === 'function') {
      window.renderSavedUserNameLabel();
    } else {
      const outEl = document.getElementById('currentUserName');
      if (outEl) {
        outEl.textContent = n ? '(' + n + ')' : '';
      }
  }
      const input = document.getElementById('userNameInput');
      if (input && n && !input.value) input.value = n;
    } catch (_) {}
  }
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('saveUserNameBtn');
    if (btn) {
      btn.addEventListener('click', () => {
        const input = document.getElementById('userNameInput');
        if (!input) return;
        const val = (input.value || '').trim();
        try { localStorage.setItem('egoUserName', val); } catch (_) {}
        applySavedNameToUI();
      });
    }
    applySavedNameToUI();
    const clr = document.getElementById('clearUserNameBtn');
    //New 15.08.2025
    const ltmExport = document.getElementById('ltmExportBtn');
    if (ltmExport) { ltmExport.addEventListener('click', exportLongTermMemory); }
    const ltmClear = document.getElementById('ltmClearBtn');
    if (ltmClear) { ltmClear.addEventListener('click', clearLongTermMemory); }
    
    if (clr) { clr.addEventListener('click', () => { try { localStorage.removeItem('egoUserName'); } catch(_){ } applySavedNameToUI(); }); }
  });

  // Feedback learning booster: keep a small replay buffer of corrected samples and fine‚Äëtune briefly.
  window._egoFeedbackReplay = async function(tfModel, inputVec, labelVec, storageKey) {
    try {
      const key = 'egoFeedbackBuffer';
      let buf = [];
      try { buf = JSON.parse(localStorage.getItem(key) || '[]'); } catch (_){}
      buf.push({ x: inputVec, y: labelVec });
      if (buf.length > 50) buf.shift();
      localStorage.setItem(key, JSON.stringify(buf));
      // quick replay
      const xs2 = tf.tensor2d(buf.map(b => b.x));
      const ys2 = tf.tensor2d(buf.map(b => b.y));
      await tfModel.fit(xs2, ys2, { epochs: 1, batchSize: Math.min(8, buf.length), shuffle: true });
      await tfModel.save('localstorage://' + storageKey);
      xs2.dispose?.(); ys2.dispose?.();
    } catch (e) { console.warn('feedback replay failed', e); }
  };
})();
</script>

</body>
</html>
